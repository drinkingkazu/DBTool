LOG:  database system was shut down at 2014-10-15 14:00:45 CDT
LOG:  database system is ready to accept connections
LOG:  autovacuum launcher started
ERROR:  function cleanconfigdb() does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CleanConfigDB();
ERROR:  invalid type name "mainrun.RunNumber%TYPE" at character 95
STATEMENT:  CREATE OR REPLACE FUNCTION InsertNewRun(CfgID INT)  RETURNS integer AS $$
	DECLARE
	    lastrun mainrun.RunNumber%TYPE;
	BEGIN
	     SELECT INTO lastrun GetLastRun();
	   
	     INSERT INTO MainRun(RunNumber,SubRunNumber,ConfigID,RunType,TimeStart) VALUES(lastrun+1,1,CfgID,333, 'now');
	
	
	    RETURN lastrun+1;
	
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "mainrun.RunNumber%TYPE" at character 116
STATEMENT:  CREATE OR REPLACE FUNCTION InsertNewSubRun(CfgID INT,run INT DEFAULT -1) RETURNS integer AS $$
	DECLARE
	    lastrun mainrun.RunNumber%TYPE;
	    lastsubrun mainrun.SubRunNumber%TYPE;
	BEGIN
	     IF run = -1  THEN
		  SELECT INTO lastrun GetLastRun();
	     ELSE 
	          lastrun := run;
	     END IF;    
	
	     SELECT INTO lastsubrun GetLastSubRun(lastrun);
	
	     INSERT INTO MainRun(RunNumber,SubRunNumber,ConfigID,RunType,TimeStart) VALUES(lastrun,lastsubrun+1,CfgID,333,'now');
	
	
	    RETURN lastsubrun+1;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "mainrun.RunNumber%TYPE" at character 83
STATEMENT:  CREATE OR REPLACE FUNCTION GetLastRun() RETURNS integer AS $$
	DECLARE
	    lastrun mainrun.RunNumber%TYPE;
	BEGIN
	    
	    SELECT INTO lastrun RunNumber FROM MainRun  ORDER BY RunNumber DESC LIMIT 1;
	
	    RETURN lastrun;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "mainrun.SubRunNumber%TYPE" at character 96
STATEMENT:  CREATE OR REPLACE FUNCTION GetLastSubRun(run INT) RETURNS integer AS $$
	DECLARE
	    lastsubrun mainrun.SubRunNumber%TYPE;
	BEGIN
	    
	    SELECT INTO lastsubrun SubRunNumber FROM MainRun WHERE RunNumber=run ORDER BY SubRunNumber DESC LIMIT 1;
	
	    RETURN lastsubrun;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "ConfigLookUp.SubConfigName%TYPE" at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION mainconfigcheck() RETURNS trigger AS $mainconfigcheck$
	    DECLARE
	    myrec RECORD;
	    tablename ConfigLookUp.SubConfigName%TYPE;
	    query   text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', NEW.subconfigtype;
	
	      SELECT  configname FROM configtypes WHERE configtypes.configtype=NEW.subconfigtype INTO tablename;
	
	      RAISE INFO 'SELECTED % ', tablename;
	
	     
	   
	  --  
	    query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigid ;
	
	    RAISE INFO ' % ', query ;
	
	    EXECUTE query INTO myrec; 
	      IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Configuration % not found', NEW.subconfigid;
	      END IF;
	
	     query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	
	      RAISE INFO ' % ', query ;
	
	      EXECUTE query INTO myrec; 
		IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
		END IF;
	--       EXECUTE 'SELECT configid FROM '
	-- 	|| tablename 
	-- 	|| ' WHERE '
	-- 	|| tablename
	-- 	|| '.configid ='
	-- 	|| substring(NEW.subconfigid,1,1) 
	--       INTO myrec;
	      --SELECT INTO myrec * FROM mainconfigtable WHERE mainconfigtable.configid=NEW.configid;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	        RETURN NEW;
	    END;
	$mainconfigcheck$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION ReturnConfigurationByNumber(requestedConfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    mainconfrec RECORD;
	    configlookuprec RECORD;
	    subconfigconfigrec subconfigreturntype;
	    subconfigquery  text ;
	    BEGIN
	       
		--select subconfigTypes and their numbers from the MainConfigTable
	
	    FOR mainconfrec IN SELECT SubConfigType,SubConfigID,SubConfigParentID,SubConfigOnMask FROM MainConfigTable 
	    WHERE Configid=requestedConfigid LOOP
	
	    RAISE INFO ' subconfig Type: %, ID: %, SubConfigParentID: %,  ',mainconfrec.SubConfigType,mainconfrec.SubConfigID,mainconfrec.SubConfigParentID;
	 
	    -- querying the lookup table to find out, what it is that we're picking up from the subconfig table
	    SELECT INTO configlookuprec * FROM ConfigLookUp WHERE ConfigLookup.SubConfigType=mainconfrec.SubConfigType;
	
	    RAISE INFO ' config name: % and parameters: % ',configlookuprec.SubConfigName,configlookuprec.SetupColumns;
	
	    -- Create JOIN of Main config table and subtable and return that
	    subconfigquery := 'SELECT *  FROM ' || configlookuprec.SubConfigName || ' WHERE ' || configlookuprec.SubConfigName || 
		  '.ConfigID = '||mainconfrec.SubConfigID;
	
	    RAISE INFO 'sub conf query: %',subconfigquery;
	
	 
	    for subconfigconfigrec in EXECUTE subconfigquery loop
	       subconfigconfigrec.ConfigName:=configlookuprec.SubConfigName;  --inserting the name for faster lookup later
	       subconfigconfigrec.ConfigType:=mainconfrec.SubConfigType;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	    end loop;
	
	  END LOOP;
	
	  RETURN;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION CreateConfigurationType(configtabletype text,columns HSTORE) RETURNS INT AS $$
	    DECLARE
	    myrec RECORD;
	    maskconfig INT;
	    newconfig INT;
	    query text;  
	    BEGIN
	        
	    -- First find if a config like this exists, if not, insert it.
	    IF EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtabletype )    
	      THEN RAISE EXCEPTION '++++++++++ Configuration Type % Already Exists +++++++++++', configtabletype;
	    END IF;
	
	    SELECT INTO myrec * FROM  ConfigLookUp ORDER BY SubConfigType DESC;
	    --SELECT INTO myrec * FROM ConfigLookUp WHERE ConfigName=configtabletype ORDER BY SubConfigType DESC;
	    
	
	    IF NOT FOUND THEN
		  newconfig:=1;
	    ELSE 
	          newconfig:=myrec.SubConfigType+1;
	    END IF;
	
	
	  -- INSERT test of HSTORE here.
	  -- nchannels must exist and parameters must be ok. 
	  --  etc... TBD
	
	
	  --CREATE TABLE - they all look the same.
	
	   query := 'CREATE TABLE '|| configtabletype ||' (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT ''nchannels=>0 '' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	    PRIMARY KEY ( ConfigID,Crate,Channel ))';   
	
	 
	   EXECUTE query; 
	-- now that we've created the table, let's also insert the name into the lookup table.
	       
	
	   query:= 'INSERT INTO ConfigLookUp(SubConfigType,SubConfigName,SetupColumns) VALUES('||newconfig||','''||configtabletype||''','''||columns||''')';
	   RAISE INFO '%',query;
	   execute query;
	   RAISE INFO 'Inserted new configuration type with ID %',newconfig;
	 
	  
	    RETURN newconfig;
	    --END IF;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GETQUERY2(configtabletype text,insubconfid INT,incrate INT, inchannel INT,columns HSTORE) RETURNS TEXT AS $$
	DECLARE
	  query text;
	  BEGIN
	  
	  query := format('SELECT * FROM %s WHERE ConfigID=%s AND channel=%s AND crate=%s',configtabletype,insubconfid,inchannel,incrate);
	--  return query;
	--  SELECT query;
	  EXECUTE query;
	--  RETURN query;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertConfigurationSet(configtabletype text,insubconfid INT,incrate INT, inchannel INT,columns HSTORE) RETURNS INT AS $$
	    DECLARE
	    myrec RECORD;
	   -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    BEGIN
	        
	 -- First find if this configuration type exists. If not, don't do anything
	    IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtabletype )    
	      THEN RAISE EXCEPTION '++++++++++ Configuration % is not defined yet! +++++++++++', configtabletype;
	    END IF;
	
	 -- Second find if a config like this exists. If does, don't do anything
	    query := format('SELECT TRUE FROM %s WHERE ConfigID=%s AND channel=%s AND crate=%s',configtabletype,insubconfid,inchannel,incrate);
	    EXECUTE query INTO myrec;
	    IF NOT myrec.bool IS NULL THEN
	      RAISE EXCEPTION '++++++++++ Configuration nr % Already Exists for Crate % and Channel % ++++++++++', insubconfid,incrate,inchannel;
	    END IF;
	
	 -- INSERT HSTORE checking, i.e. for each(hstore from ConfigLookUp Table, check that hstore key exists). TBD.
	   IF NOT EXISTS (SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtabletype AND columns ?& AKEYS(SetUpColumns))
	     THEN RAISE EXCEPTION '++++++++++ Provided HSTORE columns are lacking necessary pieces! +++++++++++';
	   END IF;
	
	   query := 'INSERT INTO '||configtabletype||'(ConfigID,crate,channel,Parameters) VALUES('||insubconfid||','||incrate||','||inchannel||','''||columns||''')';
	  -- RAISE INFO 'Inserted new configuration type with ID %',newconfig;
	 
	   execute query;
	   -- RETURN newconfig;
	    --END IF;
	   RETURN 0;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS InsertMainConfiguration( text, HSTORE) ;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertMainConfiguration(subconfigparameters HSTORE,confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
	    myrec2 RECORD;
	    myrec3 RECORD;
	    ColumnPair RECORD;
	    SubConfigCount INT;
	   -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    SubConfT INT;
	    --mainconfigexists INT;
	    localconfigexists INT;
	    BEGIN    
	
	    -- 1st CHECK: check if the provided Config ID already exsits in the MainConfigTable or not
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
		RETURN -1;
	    END IF;
	    -- now we know that the name doesn't exist or the user doesn't care.
	
	    -- 2nd CHECK: check if specified SubConfigType and SubConfigID are available or not
	    FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        -- Check if SubConfigType is valid or not
	--        RAISE NOTICE 'key:%, value: %', ColumnPair.key, ColumnPair.value;
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
		    RETURN 1;
		END IF;
		-- Check if SubConfigID is valid or not
		query := format('SELECT TRUE FROM %s WHERE COnfigID=%s',ColumnPair.key,ColumnPair.value);
		EXECUTE query INTO myrec2;
		IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
		    RETURN 1;
		END IF;
		
	    END LOOP;
	  
	    -- mainconfigexists:=1;  -- assuming it exists. Let's be proven otherwise.
	    --let's check if the configuration exists:
	    -- since we want to check the configuration sets, it's ok if we just choose the first subconfigtype and ID.
	    -- and then we loop over all of the subsets of MainconfigTable to see if they contain all of the other ones.
	
	    -- !!! Still missing. Find that the configuration we havefound does not have more rows than we need. !!!
	
	
	    SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;  -- only use the first.
	    --get subconfig type
	    ------------------------------ this repeats the functionality from later.
	
	    SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	    --looping over all mainconfigs that have the above parameters. 
	    for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	
	         -- Report
	--         RAISE NOTICE 'Checking against Main Config ID %', myrec3;
	
		 -- First check the # of sub-config types in this configuration. If not same as the # elements in subconfigparameters, continue.
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
	--	 SubConfigCount := SubConfigCount - ARRAY_LENGTH(AKEYS(subconfigparameters));
	--	 SELECT COUNT(TRUE) - SubConfigCount FROM 
	--	 IF SubConfigCount = 0
		 IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
		 END IF;
	
	         -- loop over all of the new, to be insterted config setting and check if the current configID has them all.
	         localconfigexists := 1;
		 for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	             IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
			  EXIT;   -- break out of loop. We already know, this is not the right config.
		     END IF;
	             END LOOP;
	         IF localconfigexists = 1    -- we've gone through all of the PMT settings and all exist.
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
		    RETURN -1;
		 END IF;
	     END LOOP;  -- end of myrec3 FOR loop over all of the subconfigs
	
	
	--     IF mainconfigexists = 1
	--       THEN RAISE EXCEPTION '+++++++++++++ Config already exists in MainConfigTable, with ID: %! +++++++++++++',-1;
	--     END IF;
	
	    ----------- To be improved
	
	    --------------------------------- Find the last entry
	    SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
	    IF newconfig IS NULL
	      THEN  newconfig := 0;
	    ELSE
	       newconfig := newconfig + 1;
	    END IF;
	    
	    RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
	   
	    -- Reaching this point means input values are valid. Let's insert.
	   for myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
	    INSERT INTO MainconfigTable (ConfigID,
	    	   			 SubConfigType,
					 SubConfigID, 
					 SubConfigOnMask,
					 ConfigName) VALUES(newconfig,SubConfT,CAST(myrec1.value AS INT),65636,confname);
	
	    END LOOP;
	
	   RETURN newconfig;
	   END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
	    conftype ConfigLookUp.SubConfigType%TYPE;
	    mainconfrow mainconfigtable%ROWTYPE; --.subconfigparentid%TYPE;
	    subconfigconfigrec subconfigreturntype;
	    query   text;
	    testquery text;
	    mainconfquery text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', tablename;
	
	       --'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || subconfigid ;
	      testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
	      RAISE INFO 'testquery % ', testquery;
	      EXECUTE testquery INTO conftype;
	
	      RAISE INFO 'SELECTED % ', conftype;
	
	      mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || 'AND configid='||mainconfigid;  
	
	      RAISE INFO ' % ', mainconfquery ;
	   
	      EXECUTE mainconfquery INTO mainconfrow;
	
	      RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
	  
	  ---- SELECT   
	      query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
	
	      for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;  --inserting the name for faster lookup later
	      subconfigconfigrec.ConfigType:=conftype;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	      end loop;
	      return;
	
	     -- RAISE INFO ' % ', query ;
	
	     -- EXECUTE query INTO myrec; 
	     -- IF myrec.parameterx IS NULL  THEN
		--  RAISE EXCEPTION 'Configuration % not found', subconfigid;
	     -- END IF;
	
	--- SELECT PARENT, THEN SELECT INTO RECORD the STANDARD CONFIG WHERE CRATE and CHANNEL
	--- DO we want to get the ultimate Parent?
	--- This means that the flattened parent needs to have a -1? 
	--- need to keep a list of previous parents when looping
	
	
	
	--      query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	-- 
	    --   RAISE INFO 'result? % ', myrec ;
	-- 
	--       EXECUTE query INTO myrec; 
	-- 	IF myrec.configid IS NULL  THEN
	-- 	  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
	-- 	END IF;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	       -- RETURN myrec;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  invalid type name "mainrun.RunNumber%TYPE" at character 95
STATEMENT:  CREATE OR REPLACE FUNCTION InsertNewRun(CfgID INT)  RETURNS integer AS $$
	DECLARE
	    lastrun mainrun.RunNumber%TYPE;
	BEGIN
	     SELECT INTO lastrun GetLastRun();
	   
	     INSERT INTO MainRun(RunNumber,SubRunNumber,ConfigID,RunType,TimeStart) VALUES(lastrun+1,1,CfgID,333, 'now');
	
	
	    RETURN lastrun+1;
	
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "mainrun.RunNumber%TYPE" at character 116
STATEMENT:  CREATE OR REPLACE FUNCTION InsertNewSubRun(CfgID INT,run INT DEFAULT -1) RETURNS integer AS $$
	DECLARE
	    lastrun mainrun.RunNumber%TYPE;
	    lastsubrun mainrun.SubRunNumber%TYPE;
	BEGIN
	     IF run = -1  THEN
		  SELECT INTO lastrun GetLastRun();
	     ELSE 
	          lastrun := run;
	     END IF;    
	
	     SELECT INTO lastsubrun GetLastSubRun(lastrun);
	
	     INSERT INTO MainRun(RunNumber,SubRunNumber,ConfigID,RunType,TimeStart) VALUES(lastrun,lastsubrun+1,CfgID,333,'now');
	
	
	    RETURN lastsubrun+1;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "mainrun.RunNumber%TYPE" at character 83
STATEMENT:  CREATE OR REPLACE FUNCTION GetLastRun() RETURNS integer AS $$
	DECLARE
	    lastrun mainrun.RunNumber%TYPE;
	BEGIN
	    
	    SELECT INTO lastrun RunNumber FROM MainRun  ORDER BY RunNumber DESC LIMIT 1;
	
	    RETURN lastrun;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "mainrun.SubRunNumber%TYPE" at character 96
STATEMENT:  CREATE OR REPLACE FUNCTION GetLastSubRun(run INT) RETURNS integer AS $$
	DECLARE
	    lastsubrun mainrun.SubRunNumber%TYPE;
	BEGIN
	    
	    SELECT INTO lastsubrun SubRunNumber FROM MainRun WHERE RunNumber=run ORDER BY SubRunNumber DESC LIMIT 1;
	
	    RETURN lastsubrun;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  invalid type name "ConfigLookUp.SubConfigName%TYPE" at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION mainconfigcheck() RETURNS trigger AS $mainconfigcheck$
	    DECLARE
	    myrec RECORD;
	    tablename ConfigLookUp.SubConfigName%TYPE;
	    query   text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', NEW.subconfigtype;
	
	      SELECT  configname FROM configtypes WHERE configtypes.configtype=NEW.subconfigtype INTO tablename;
	
	      RAISE INFO 'SELECTED % ', tablename;
	
	     
	   
	  --  
	    query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigid ;
	
	    RAISE INFO ' % ', query ;
	
	    EXECUTE query INTO myrec; 
	      IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Configuration % not found', NEW.subconfigid;
	      END IF;
	
	     query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	
	      RAISE INFO ' % ', query ;
	
	      EXECUTE query INTO myrec; 
		IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
		END IF;
	--       EXECUTE 'SELECT configid FROM '
	-- 	|| tablename 
	-- 	|| ' WHERE '
	-- 	|| tablename
	-- 	|| '.configid ='
	-- 	|| substring(NEW.subconfigid,1,1) 
	--       INTO myrec;
	      --SELECT INTO myrec * FROM mainconfigtable WHERE mainconfigtable.configid=NEW.configid;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	        RETURN NEW;
	    END;
	$mainconfigcheck$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION ReturnConfigurationByNumber(requestedConfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    mainconfrec RECORD;
	    configlookuprec RECORD;
	    subconfigconfigrec subconfigreturntype;
	    subconfigquery  text ;
	    BEGIN
	       
		--select subconfigTypes and their numbers from the MainConfigTable
	
	    FOR mainconfrec IN SELECT SubConfigType,SubConfigID,SubConfigParentID,SubConfigOnMask FROM MainConfigTable 
	    WHERE Configid=requestedConfigid LOOP
	
	    RAISE INFO ' subconfig Type: %, ID: %, SubConfigParentID: %,  ',mainconfrec.SubConfigType,mainconfrec.SubConfigID,mainconfrec.SubConfigParentID;
	 
	    -- querying the lookup table to find out, what it is that we're picking up from the subconfig table
	    SELECT INTO configlookuprec * FROM ConfigLookUp WHERE ConfigLookup.SubConfigType=mainconfrec.SubConfigType;
	
	    RAISE INFO ' config name: % and parameters: % ',configlookuprec.SubConfigName,configlookuprec.SetupColumns;
	
	    -- Create JOIN of Main config table and subtable and return that
	    subconfigquery := 'SELECT *  FROM ' || configlookuprec.SubConfigName || ' WHERE ' || configlookuprec.SubConfigName || 
		  '.ConfigID = '||mainconfrec.SubConfigID;
	
	    RAISE INFO 'sub conf query: %',subconfigquery;
	
	 
	    for subconfigconfigrec in EXECUTE subconfigquery loop
	       subconfigconfigrec.ConfigName:=configlookuprec.SubConfigName;  --inserting the name for faster lookup later
	       subconfigconfigrec.ConfigType:=mainconfrec.SubConfigType;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	    end loop;
	
	  END LOOP;
	
	  RETURN;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION CreateConfigurationType(configtabletype text,columns HSTORE) RETURNS INT AS $$
	    DECLARE
	    myrec RECORD;
	    maskconfig INT;
	    newconfig INT;
	    query text;  
	    BEGIN
	        
	    -- First find if a config like this exists, if not, insert it.
	    IF EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtabletype )    
	      THEN RAISE EXCEPTION '++++++++++ Configuration Type % Already Exists +++++++++++', configtabletype;
	    END IF;
	
	    SELECT INTO myrec * FROM  ConfigLookUp ORDER BY SubConfigType DESC;
	    --SELECT INTO myrec * FROM ConfigLookUp WHERE ConfigName=configtabletype ORDER BY SubConfigType DESC;
	    
	
	    IF NOT FOUND THEN
		  newconfig:=1;
	    ELSE 
	          newconfig:=myrec.SubConfigType+1;
	    END IF;
	
	
	  -- INSERT test of HSTORE here.
	  -- nchannels must exist and parameters must be ok. 
	  --  etc... TBD
	
	
	  --CREATE TABLE - they all look the same.
	
	   query := 'CREATE TABLE '|| configtabletype ||' (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT ''nchannels=>0 '' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	    PRIMARY KEY ( ConfigID,Crate,Channel ))';   
	
	 
	   EXECUTE query; 
	-- now that we've created the table, let's also insert the name into the lookup table.
	       
	
	   query:= 'INSERT INTO ConfigLookUp(SubConfigType,SubConfigName,SetupColumns) VALUES('||newconfig||','''||configtabletype||''','''||columns||''')';
	   RAISE INFO '%',query;
	   execute query;
	   RAISE INFO 'Inserted new configuration type with ID %',newconfig;
	 
	  
	    RETURN newconfig;
	    --END IF;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GETQUERY2(configtabletype text,insubconfid INT,incrate INT, inchannel INT,columns HSTORE) RETURNS TEXT AS $$
	DECLARE
	  query text;
	  BEGIN
	  
	  query := format('SELECT * FROM %s WHERE ConfigID=%s AND channel=%s AND crate=%s',configtabletype,insubconfid,inchannel,incrate);
	--  return query;
	--  SELECT query;
	  EXECUTE query;
	--  RETURN query;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertConfigurationSet(configtabletype text,insubconfid INT,incrate INT, inchannel INT,columns HSTORE) RETURNS INT AS $$
	    DECLARE
	    myrec RECORD;
	   -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    BEGIN
	        
	 -- First find if this configuration type exists. If not, don't do anything
	    IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtabletype )    
	      THEN RAISE EXCEPTION '++++++++++ Configuration % is not defined yet! +++++++++++', configtabletype;
	    END IF;
	
	 -- Second find if a config like this exists. If does, don't do anything
	    query := format('SELECT TRUE FROM %s WHERE ConfigID=%s AND channel=%s AND crate=%s',configtabletype,insubconfid,inchannel,incrate);
	    EXECUTE query INTO myrec;
	    IF NOT myrec.bool IS NULL THEN
	      RAISE EXCEPTION '++++++++++ Configuration nr % Already Exists for Crate % and Channel % ++++++++++', insubconfid,incrate,inchannel;
	    END IF;
	
	 -- INSERT HSTORE checking, i.e. for each(hstore from ConfigLookUp Table, check that hstore key exists). TBD.
	   IF NOT EXISTS (SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtabletype AND columns ?& AKEYS(SetUpColumns))
	     THEN RAISE EXCEPTION '++++++++++ Provided HSTORE columns are lacking necessary pieces! +++++++++++';
	   END IF;
	
	   query := 'INSERT INTO '||configtabletype||'(ConfigID,crate,channel,Parameters) VALUES('||insubconfid||','||incrate||','||inchannel||','''||columns||''')';
	  -- RAISE INFO 'Inserted new configuration type with ID %',newconfig;
	 
	   execute query;
	   -- RETURN newconfig;
	    --END IF;
	   RETURN 0;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS InsertMainConfiguration( text, HSTORE) ;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertMainConfiguration(subconfigparameters HSTORE,confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
	    myrec2 RECORD;
	    myrec3 RECORD;
	    ColumnPair RECORD;
	    SubConfigCount INT;
	   -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    SubConfT INT;
	    --mainconfigexists INT;
	    localconfigexists INT;
	    BEGIN    
	
	    -- 1st CHECK: check if the provided Config ID already exsits in the MainConfigTable or not
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
		RETURN -1;
	    END IF;
	    -- now we know that the name doesn't exist or the user doesn't care.
	
	    -- 2nd CHECK: check if specified SubConfigType and SubConfigID are available or not
	    FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        -- Check if SubConfigType is valid or not
	--        RAISE NOTICE 'key:%, value: %', ColumnPair.key, ColumnPair.value;
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
		    RETURN 1;
		END IF;
		-- Check if SubConfigID is valid or not
		query := format('SELECT TRUE FROM %s WHERE COnfigID=%s',ColumnPair.key,ColumnPair.value);
		EXECUTE query INTO myrec2;
		IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
		    RETURN 1;
		END IF;
		
	    END LOOP;
	  
	    -- mainconfigexists:=1;  -- assuming it exists. Let's be proven otherwise.
	    --let's check if the configuration exists:
	    -- since we want to check the configuration sets, it's ok if we just choose the first subconfigtype and ID.
	    -- and then we loop over all of the subsets of MainconfigTable to see if they contain all of the other ones.
	
	    -- !!! Still missing. Find that the configuration we havefound does not have more rows than we need. !!!
	
	
	    SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;  -- only use the first.
	    --get subconfig type
	    ------------------------------ this repeats the functionality from later.
	
	    SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	    --looping over all mainconfigs that have the above parameters. 
	    for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	
	         -- Report
	--         RAISE NOTICE 'Checking against Main Config ID %', myrec3;
	
		 -- First check the # of sub-config types in this configuration. If not same as the # elements in subconfigparameters, continue.
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
	--	 SubConfigCount := SubConfigCount - ARRAY_LENGTH(AKEYS(subconfigparameters));
	--	 SELECT COUNT(TRUE) - SubConfigCount FROM 
	--	 IF SubConfigCount = 0
		 IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
		 END IF;
	
	         -- loop over all of the new, to be insterted config setting and check if the current configID has them all.
	         localconfigexists := 1;
		 for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	             IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
			  EXIT;   -- break out of loop. We already know, this is not the right config.
		     END IF;
	             END LOOP;
	         IF localconfigexists = 1    -- we've gone through all of the PMT settings and all exist.
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
		    RETURN -1;
		 END IF;
	     END LOOP;  -- end of myrec3 FOR loop over all of the subconfigs
	
	
	--     IF mainconfigexists = 1
	--       THEN RAISE EXCEPTION '+++++++++++++ Config already exists in MainConfigTable, with ID: %! +++++++++++++',-1;
	--     END IF;
	
	    ----------- To be improved
	
	    --------------------------------- Find the last entry
	    SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
	    IF newconfig IS NULL
	      THEN  newconfig := 0;
	    ELSE
	       newconfig := newconfig + 1;
	    END IF;
	    
	    RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
	   
	    -- Reaching this point means input values are valid. Let's insert.
	   for myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
	    INSERT INTO MainconfigTable (ConfigID,
	    	   			 SubConfigType,
					 SubConfigID, 
					 SubConfigOnMask,
					 ConfigName) VALUES(newconfig,SubConfT,CAST(myrec1.value AS INT),65636,confname);
	
	    END LOOP;
	
	   RETURN newconfig;
	   END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
	    conftype ConfigLookUp.SubConfigType%TYPE;
	    mainconfrow mainconfigtable%ROWTYPE; --.subconfigparentid%TYPE;
	    subconfigconfigrec subconfigreturntype;
	    query   text;
	    testquery text;
	    mainconfquery text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', tablename;
	
	       --'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || subconfigid ;
	      testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
	      RAISE INFO 'testquery % ', testquery;
	      EXECUTE testquery INTO conftype;
	
	      RAISE INFO 'SELECTED % ', conftype;
	
	      mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || 'AND configid='||mainconfigid;  
	
	      RAISE INFO ' % ', mainconfquery ;
	   
	      EXECUTE mainconfquery INTO mainconfrow;
	
	      RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
	  
	  ---- SELECT   
	      query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
	
	      for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;  --inserting the name for faster lookup later
	      subconfigconfigrec.ConfigType:=conftype;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	      end loop;
	      return;
	
	     -- RAISE INFO ' % ', query ;
	
	     -- EXECUTE query INTO myrec; 
	     -- IF myrec.parameterx IS NULL  THEN
		--  RAISE EXCEPTION 'Configuration % not found', subconfigid;
	     -- END IF;
	
	--- SELECT PARENT, THEN SELECT INTO RECORD the STANDARD CONFIG WHERE CRATE and CHANNEL
	--- DO we want to get the ultimate Parent?
	--- This means that the flattened parent needs to have a -1? 
	--- need to keep a list of previous parents when looping
	
	
	
	--      query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	-- 
	    --   RAISE INFO 'result? % ', myrec ;
	-- 
	--       EXECUTE query INTO myrec; 
	-- 	IF myrec.configid IS NULL  THEN
	-- 	  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
	-- 	END IF;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	       -- RETURN myrec;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist at character 116
STATEMENT:  CREATE TABLE  ConfigLookUp  (
	   SubConfigType  INT NOT NULL,
	   SubConfigName VARCHAR  NOT NULL,
	   SetupColumns  HSTORE,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	  PRIMARY KEY ( SubConfigType )
	);
ERROR:  type "hstore" does not exist
STATEMENT:  CREATE  TYPE subconfigreturntype as 
	(  ConfigID  INTEGER ,
	   Crate  SMALLINT  ,
	   Channel  SMALLINT ,
	   Parameters  HSTORE , 
	   userID  VARCHAR,
	   TimeStamp  TIMESTAMP,
	   ConfigName varchar,
	   ConfigType INTEGER);
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('TriggerConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('PMTConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('TPCConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('CalibrationConfig','');
FATAL:  role "kterao" does not exist
ERROR:  extension "hstore" already exists
STATEMENT:  CREATE EXTENSION HSTORE;
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test1','test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',0,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',1,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',2,0,0,'test1=>1');
ERROR:  relation "test2" already exists
CONTEXT:  SQL statement "CREATE TABLE Test2 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test2','test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',0,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',1,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',2,0,0,'test2=>1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0'::hstore,'MainTest3');
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test1','test1=>1');
ERROR:  syntax error at or near "return" at character 1
STATEMENT:  return;
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',0,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',1,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',2,0,0,'test1=>1');
ERROR:  relation "test2" already exists
CONTEXT:  SQL statement "CREATE TABLE Test2 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test2','test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',0,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',1,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',2,0,0,'test2=>1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0'::hstore,'MainTest3');
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test1','test1=>1');
ERROR:  syntax error at or near "raiserror" at character 1
STATEMENT:  raiserror('Oh no a fatal error', 20, -1) with log;
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',0,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',1,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',2,0,0,'test1=>1');
ERROR:  relation "test2" already exists
CONTEXT:  SQL statement "CREATE TABLE Test2 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test2','test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',0,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',1,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',2,0,0,'test2=>1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0'::hstore,'MainTest3');
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test1','test1=>1');
ERROR:  syntax error at or near "RAISE" at character 1
STATEMENT:  RAISE EXCEPTION 'exiting..';
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',0,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',1,0,0,'test1=>1');
ERROR:  ++++++++++ Configuration Test1 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test1',2,0,0,'test1=>1');
ERROR:  relation "test2" already exists
CONTEXT:  SQL statement "CREATE TABLE Test2 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test2','test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',0,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',1,0,0,'test2=>1');
ERROR:  ++++++++++ Configuration Test2 is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('Test2',2,0,0,'test2=>1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>1,Test2=>0'::hstore,'MainTest3');
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test1','test1=>1');
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test1','test1=>1');
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID  INT NOT NULL   DEFAULT NULL,
	   ParentConfigID  INT NOT NULL  DEFAULT -1,
	   Crate  SMALLINT  NOT NULL DEFAULT 0,
	   Channel  INT  NOT NULL DEFAULT 0,
	   Parameters  HSTORE  NOT NULL DEFAULT 'nchannels=>0 ' ,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID,Crate,Channel ))"
	PL/pgSQL function createconfigurationtype(text,hstore) line 43 at EXECUTE statement
STATEMENT:  SELECT CreateConfigurationType('Test1','test1=>1');
ERROR:  +++++++++++++ Config with name MainTest1 already exists in MainConfigTable! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  +++++++++++++ Config with name MainTest1 already exists in MainConfigTable! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  +++++++++++++ Config with name MainTest1 already exists in MainConfigTable! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  +++++++++++++ This Configuration exists MainConfigTable, with ID: 0! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest2');
ERROR:  +++++++++++++ Config with name MainTest1 already exists in MainConfigTable! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest1');
ERROR:  +++++++++++++ This Configuration exists MainConfigTable, with ID: 0! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('Test1=>0,Test2=>0,Test3=>0'::hstore,'MainTest2');
LOG:  unexpected EOF on client connection with an open transaction
ERROR:  Project kazu already exists.
CONTEXT:  SQL statement "SELECT MakeProjTable(project_name)"
	PL/pgSQL function defineproject(text,text,integer,text,integer,integer,hstore,boolean) line 45 at SQL statement
STATEMENT:  SELECT DefineProject('kazu','echo hello world',10,'kazuhiro@nevis.columbia.edu ',1,1,'a=>b,c=>d');
ERROR:  MainRun table contains no run number!
CONTEXT:  PL/pgSQL function getruns(text[],smallint[]) line 38 at FOR over SELECT rows
STATEMENT:  SELECT Run, SubRun FROM GetRuns(ARRAY['dummy_nubin_xfer'::TEXT,'dummy_daq'::TEXT],ARRAY[1::SMALLINT,0::SMALLINT]);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
STATEMENT:  SELECT DoesProjectExist('dummy_nubin_xfer')
LOG:  unexpected EOF on client connection with an open transaction
ERROR:  ++++++++++ Configuration pmtconfig is not defined yet! +++++++++++
STATEMENT:  SELECT InsertConfigurationSet('pmtconfig', 0, 0, 0, ' "calib_delay"=>"0x0", "deadtime"=>"0x0", "frame_size"=>"25600", "mask0"=>"0x0", "mask1"=>"0x0", "mask2"=>"0x0", "mask3"=>"0x0", "mask4"=>"0x0", "mask5"=>"0x0", "mask6"=>"0x0", "mask7"=>"0x0", "mask8"=>"0x0", "module_address"=>"1", "prescale0"=>"0x0", "prescale1"=>"0x0", "prescale2"=>"0x0", "prescale3"=>"0x0", "prescale4"=>"0x0", "prescale5"=>"0x0", "prescale6"=>"0x0", "prescale7"=>"0x0", "prescale8"=>"0x0", "pulse_delay1"=>"0x0", "pulse_delay2"=>"0x0", "pulse_width1"=>"0x0", "pulse_width2"=>"0x0" ');
ERROR:  function createconfigurationtype(unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('pmt_fem_mod');
ERROR:  type "unitconfig" already exists
STATEMENT:  CREATE TYPE UnitConfig AS ( Crate INT, Slot INT, Channel INT, Params HSTORE );
ERROR:  type "unitconfig" already exists
STATEMENT:  CREATE TYPE UnitConfig AS ( Crate INT, Slot INT, Channel INT, Params HSTORE );
ERROR:  relation "test1" already exists
CONTEXT:  SQL statement "CREATE TABLE Test1 (
	   ConfigID        INT NOT  NULL DEFAULT NULL,
	   Crate      SMALLINT NOT  NULL DEFAULT -1,
	   Slot       SMALLINT NOT  NULL DEFAULT -1,
	   Channel    SMALLINT NOT  NULL DEFAULT -1,
	   Parameters   HSTORE NOT  NULL,
	   Mask       BIT(64)  NOT  NULL,
	   userID      VARCHAR NULL DEFAULT NULL,
	   TimeStamp TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID, Crate, Slot, Channel ))"
	PL/pgSQL function createcrateconfiguration(text) line 35 at EXECUTE statement
STATEMENT:  SELECT CreateCrateConfiguration( 'Test1');
ERROR:  ++++++++++ Configuration Test1 does not exist! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1'::TEXT, 0,
					 'A=>1'::HSTORE,
					 'B=>2'::HSTORE,
					 'C=>3'::HSTORE);
ERROR:  ++++++++++ Configuration Test1 does not exist! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1', 1,
					 'A=>1'::HSTORE,
					 'B=>2'::HSTORE,
					 'C=>3'::HSTORE);
ERROR:  ++++++++++ Configuration Test1 does not exist! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1', 1,
					 'A=>1',
					 'B=>2',
					 'C=>3');
ERROR:  relation "test2" already exists
CONTEXT:  SQL statement "CREATE TABLE Test2 (
	   ConfigID        INT NOT  NULL DEFAULT NULL,
	   Crate      SMALLINT NOT  NULL DEFAULT -1,
	   Slot       SMALLINT NOT  NULL DEFAULT -1,
	   Channel    SMALLINT NOT  NULL DEFAULT -1,
	   Parameters   HSTORE NOT  NULL,
	   Mask       BIT(64)  NOT  NULL,
	   userID      VARCHAR NULL DEFAULT NULL,
	   TimeStamp TIMESTAMP NULL DEFAULT NULL,
	   PRIMARY KEY ( ConfigID, Crate, Slot, Channel ))"
	PL/pgSQL function createcrateconfiguration(text) line 35 at EXECUTE statement
STATEMENT:  SELECT CreateCrateConfiguration( 'Test2');
ERROR:  ++++++++++ Configuration Test2 does not exist! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test2', 0,
					 'A=>1,X=>0',
					 'B=>2,Y=>0',
					 'C=>3,Z=>0');
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT AppendCrateConfiguration( 'Test2', 
	       				 0,   
					 1,   
					 -1,  
					 -1,  
	       				 '1'::BIT(64),
					 'X=>1' );
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT AppendCrateConfiguration( 'Test2', 
	       				 0,   
					 2,   
					 -1,  
					 -1,  
	       				 '11'::BIT(64),
					 'X=>2' );
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT AppendCrateConfiguration( 'Test2', 
	       				 0,   
					 2,   
					 1,  
					 -1,  
	       				 '111'::BIT(64),
					 'Y=>1' );
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT AppendCrateConfiguration( 'Test2', 
	       				 0,   
					 2,   
					 1,  
					 1,  
	       				 '111'::BIT(64),
					 'Z=>1' );
ERROR:  ++++++++++++ Configuration Test1 is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration( 'Test1=>0,Test2=>0'::hstore,
	       				'Test1=>1,Test2=>1'::hstore,
	       				'MainTest1');
ERROR:  ++++++++++ Configuration Test1 with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1', 1,
					 'A=>1',
					 'B=>2',
					 'C=>3');
ERROR:  ++++++++++ Configuration Test1 with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1', 1,
					 'A=>1',
					 'B=>2',
					 'C=>3');
ERROR:  ++++++++++ Configuration Test1 with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1', 1,
					 'A=>1',
					 'B=>2',
					 'C=>3');
ERROR:  ++++++++++ Configuration Test1 with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1', 1,
					 'A=>1',
					 'B=>2',
					 'C=>3');
ERROR:  ++++++++++ Configuration Test1 with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertCrateConfiguration( 'Test1', 1,
					 'A=>1',
					 'B=>2',
					 'C=>3');
ERROR:  function createconfigurationtype(unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('pmt_fem_mod');
ERROR:  function createsubconfiguration(unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateSubConfiguration('pmt_fem_mod');
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 0 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,0::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,1::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,1::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  relation "configlookup" does not exist at character 105
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	   SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = SCfgName LIMIT 1
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigParameters(SCfgName TEXT) RETURNS SETOF TEXT AS $$
	   SELECT skeys(setupcolumns) FROM configlookup WHERE subconfigname = SCfgName
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 128
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigNameAndID() RETURNS SETOF RECORD AS $$
	       SELECT SubConfigName, SubConfigType FROM ConfigLookUp ORDER BY SubConfigType
	$$ LANGUAGE SQL;
ERROR:  invalid type name "ConfigLookUp.SubConfigName%TYPE" at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION mainconfigcheck() RETURNS trigger AS $mainconfigcheck$
	    DECLARE
	    myrec RECORD;
	    tablename ConfigLookUp.SubConfigName%TYPE;
	    query   text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', NEW.subconfigtype;
	
	      SELECT  configname FROM configtypes WHERE configtypes.configtype=NEW.subconfigtype INTO tablename;
	
	      RAISE INFO 'SELECTED % ', tablename;
	
	     
	   
	  --  
	    query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigid ;
	
	    RAISE INFO ' % ', query ;
	
	    EXECUTE query INTO myrec; 
	      IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Configuration % not found', NEW.subconfigid;
	      END IF;
	
	     query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	
	      RAISE INFO ' % ', query ;
	
	      EXECUTE query INTO myrec; 
		IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
		END IF;
	--       EXECUTE 'SELECT configid FROM '
	-- 	|| tablename 
	-- 	|| ' WHERE '
	-- 	|| tablename
	-- 	|| '.configid ='
	-- 	|| substring(NEW.subconfigid,1,1) 
	--       INTO myrec;
	      --SELECT INTO myrec * FROM mainconfigtable WHERE mainconfigtable.configid=NEW.configid;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	        RETURN NEW;
	    END;
	$mainconfigcheck$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION ReturnConfigurationByNumber(requestedConfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    mainconfrec RECORD;
	    configlookuprec RECORD;
	    subconfigconfigrec subconfigreturntype;
	    subconfigquery  text ;
	    BEGIN
	       
		--select subconfigTypes and their numbers from the MainConfigTable
	
	    FOR mainconfrec IN SELECT SubConfigType,SubConfigID,SubConfigParentID,SubConfigOnMask FROM MainConfigTable 
	    WHERE Configid=requestedConfigid LOOP
	
	    RAISE INFO ' subconfig Type: %, ID: %, SubConfigParentID: %,  ',mainconfrec.SubConfigType,mainconfrec.SubConfigID,mainconfrec.SubConfigParentID;
	 
	    -- querying the lookup table to find out, what it is that we're picking up from the subconfig table
	    SELECT INTO configlookuprec * FROM ConfigLookUp WHERE ConfigLookup.SubConfigType=mainconfrec.SubConfigType;
	
	    RAISE INFO ' config name: % and parameters: % ',configlookuprec.SubConfigName,configlookuprec.SetupColumns;
	
	    -- Create JOIN of Main config table and subtable and return that
	    subconfigquery := 'SELECT *  FROM ' || configlookuprec.SubConfigName || ' WHERE ' || configlookuprec.SubConfigName || 
		  '.ConfigID = '||mainconfrec.SubConfigID;
	
	    RAISE INFO 'sub conf query: %',subconfigquery;
	
	 
	    for subconfigconfigrec in EXECUTE subconfigquery loop
	       subconfigconfigrec.ConfigName:=configlookuprec.SubConfigName;  --inserting the name for faster lookup later
	       subconfigconfigrec.ConfigType:=mainconfrec.SubConfigType;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	    end loop;
	
	  END LOOP;
	
	  RETURN;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GETQUERY2(configtabletype text,insubconfid INT,inmodule INT,columns HSTORE) RETURNS TEXT AS $$
	DECLARE
	  query text;
	  BEGIN
	  
	  query := format('SELECT * FROM %s WHERE ConfigID=%s AND ModuleID=%s',configtabletype,insubconfid,inmodule);
	--  return query;
	--  SELECT query;
	  EXECUTE query;
	--  RETURN query;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewCrateConfiguration( config_name TEXT,
	     	      	 			            config_id   INT,
							    crate_id    INT,
							    slot_id     INT,
							    channel_id  INT,
							    params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewSubConfiguration( config_name TEXT,
	     	      	 			          config_id   INT,
							  crate_id    INT,
							  slot_id     INT,
							  channel_id  INT,
							  params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION CheckNewSubConfiguration( config_name TEXT,
	       	  	  	   			     config_id   INT,
							     crate_id    INT,
							     slot_id     INT,
							     channel_id  INT,
							     params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	    myrec RECORD;
	    newconfig INT;
	    query text;  
	    ColumnPair RECORD;
	  BEGIN
	
	 -- Check 0) Possible combination of crate_id, slot_id, and channel_id
	    IF crate_id < 0 AND NOT (crate_id = -1 OR crate_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Crate ID: % +++++++++++', crate_id;
	      RETURN 1;
	
	    ELSIF slot_id < 0 AND NOT (slot_id = -1 OR slot_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Slot ID: % +++++++++++', slot_id;
	      RETURN 1;
	
	    ELSIF channel_id < 0 AND NOT (channel_id = -1 OR channel_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Channel ID: % +++++++++++', channel_id;
	      RETURN 1;
	
	    ELSIF ((crate_id + channel_id + slot_id) < -1001) THEN
	      RAISE NOTICE '++++++++++ Duplicate -999 values among (crate,slot,channel)=(%,%,%) ++++++++++++', crate_id, slot_id, channel_id;
	      RETURN 1;
	
	    ELSIF channel_id = -999 AND (crate_id = -1  AND slot_id >= 0) THEN
	      RAISE NOTICE '++++++++++ Crate ID must be 0 or positive integer for a specific slot default channel! ++++++++++';
	      RETURN 1;
	
	    ELSIF slot_id = -999 AND  channel_id != -1 THEN
	      RAISE NOTICE '++++++++++ Channel ID must be -1 if Slot ID is -999! +++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -999 AND (slot_id >=0 OR channel_id >=0 ) THEN
	      RAISE NOTICE '++++++++++ Slot and Channel ID must be -1 for default Crate config (ID=-999) ++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -1 AND (slot_id >= 0 OR channel_id >= 0) THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (-1, %, %) not allowed! +++++++++++',slot_id,channel_id;
	      RETURN 1;
	
	    ELSIF crate_id >= 0 AND slot_id = -1 AND channel_id >= 0 THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (%, -1, %) not allowed! +++++++++++',crate_id,channel_id;
	      RETURN 1;
	
	    END IF;
	
	 -- Check 1) find if this configuration type exists. If not, don't do anything
	    IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	      RAISE NOTICE '++++++++++ Configuration % is not defined yet! +++++++++++', config_name;
	      RETURN 1;
	    END IF;
	
	 -- Check 2) find if this config ID is already defined or not. If not, don't do anything
	    query := format('SELECT 1 AS VAL FROM %s WHERE ConfigID=%s LIMIT 1;',config_name,config_id);
	    EXECUTE query INTO myrec;
	    IF myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ Configuration % with ID % is not defined yet! +++++++++++', config_name, config_id;
	      RETURN 1;
	    END IF;
	
	 -- Check 3) find if a config like this exists. If does, don't do anything
	    query := format('SELECT TRUE AS VAL FROM %s WHERE ConfigID=%s AND Crate=%s AND Slot=%s AND Channel=%s',config_name,config_id, crate_id, slot_id, channel_id);
	    EXECUTE query INTO myrec;
	    IF NOT myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ (ConfigID,Crate,Slot,Channel) = (%,%,%,%) already exists! ++++++++++', config_id, crate_id, slot_id, channel_id;
	      RETURN 1;
	    END IF;
	
	    -- INSERT HSTORE checking, i.e. for each(hstore from ConfigLookUp Table, check that hstore key exists). TBD.
	    --IF NOT EXISTS (SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtablename AND columns ?& AKEYS(SetUpColumns)) THEN
	      --RAISE NOTICE '++++++++++ Provided HSTORE columns are lacking necessary pieces! +++++++++++';
	      --RETURN 1;
	    --END IF;
	    RETURN 0;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertCrateConfiguration( config_name     TEXT,
	  	      	 	 	  		   config_id       INT,
	     	      	 	  			   crate_default   HSTORE, 
							   slot_default      HSTORE, 
							   channel_default HSTORE, 
							   crate_mask   BIT(64),
							   slot_mask    BIT(64),
							   channel_mask BIT(64)
							   );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertSubConfiguration( config_name     TEXT,
	  	      	 	 			 config_id       INT,
	     	      	 	 			 crate_default   HSTORE, 
							 slot_default      HSTORE, 
							 channel_default HSTORE, 
							 crate_mask   BIT(64),
							 slot_mask    BIT(64),
							 channel_mask BIT(64)
							 );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertSubConfiguration( config_name     TEXT,
	     	      	 	 			   config_id       INT,
	     	      	 	 			   crate_default   HSTORE, 
							   slot_default    HSTORE, 
	 						   channel_default HSTORE,
							   crate_mask   BIT(64) DEFAULT '111111111111111'::BIT(64),
							   slot_mask    BIT(64) DEFAULT '1111111111111111111111111111111111111111111111111111111111111111',
	 						   channel_mask BIT(64) DEFAULT '0'::BIT(64)
							   ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  myrec RECORD;
	  BEGIN
	
	  IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	    RAISE EXCEPTION '++++++++++ Configuration % does not exist! +++++++++++', config_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID=%s LIMIT 1',config_name,config_id);
	  EXECUTE query INTO myrec;
	  IF NOT myrec.bool IS NULL THEN
	    RAISE EXCEPTION '++++++++++ Configuration % with ID % is already defined! +++++++++++', config_name, config_id;
	  END IF;
	
	--  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-999,-1,'''||slot_default||''','''||slot_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-1,-999,'''||channel_default||''','''||channel_mask||''')';
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendCrateConfiguration( config_name TEXT,
	     	      	 	 			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendSubConfiguration( config_name TEXT,
	     	      	 	 			 config_id   INT,
							 crate_id    INT,
							 slot_id     INT,
							 channel_id  INT,
							 Mask        BIT(64),
							 params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION AppendSubConfiguration( config_name TEXT,
	       	  	  	   			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  rec   RECORD;
	  BEGIN
	  
	    SELECT CheckNewCrateConfiguration(config_name, config_id, crate_id, slot_id, channel_id, params) AS VAL INTO rec;
	    IF rec.VAL = 1 THEN
	      RAISE EXCEPTION '+++++++++ Invalid subconfiguration! Aborting +++++++++';
	    RETURN 1;
	  END IF;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||','||crate_id||','''||slot_id||''','''||channel_id||''','''||params||''','''||Mask||''')';
	  RAISE INFO '%', query;
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateConfig( sub_conf_name TEXT,
	     	      	 			   sub_conf_id   INT,
						   crate_id      INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  conf_params.Crate := crate_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate = %s OR Crate = -999) AND SLOT = -1 AND Channel = -1 ORDER BY Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotConfig( sub_conf_name TEXT,
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT,
						  slot_id       INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  slot_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id);
	
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetChannelConfig( sub_conf_name TEXT,
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT,
						     channel_id    INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  channel_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;
	  IF NOT ARRAY[channel_id] <@ channel_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot,Channel) = (%,%,%) is not enabled! ++++++++++++',crate_id,slot_id,channel_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	  conf_params.Channel := channel_id;
	  conf_params.Params  := '';  
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Channel = -999 OR (Crate = %s AND Slot = %s AND Channel = %s)) ORDER BY Channel ASC, Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id,
			   channel_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	 sub_conf_id   INT,
						     	 crate_id      INT,
						     	 slot_id       INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  params HSTORE;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  channel_v INT[];
	  channel_id INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN NEXT conf_params;
	  ELSE
	
	    conf_params.Crate   := crate_id;
	    conf_params.Slot    := slot_id;
	    conf_params.Channel := -1;
	    conf_params.Params  := '';
	
	    query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	     sub_conf_name,
			     sub_conf_id,
			     crate_id,
			     slot_id);
	
	    FOR rec IN EXECUTE query LOOP
	      conf_params.Params := conf_params.Params || rec.Parameters;
	    END LOOP;
	
	    RETURN NEXT conf_params;
	
	    SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;  
	    FOREACH channel_id IN ARRAY channel_v LOOP
	
	      SELECT GetChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id, channel_id) INTO rec;
	      
	      conf_params := rec.getchannelconfig;
	      
	      RETURN NEXT conf_params;
	    END LOOP;
	  END IF;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	      sub_conf_id   INT,
						     	      crate_id      INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  slot_id   INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  --SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO conf_params;
	  SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO rec;
	  conf_params := rec.getcrateconfig;
	  RETURN NEXT conf_params;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  FOREACH slot_id IN ARRAY slot_v LOOP
	    FOR rec IN SELECT GetSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id) LOOP
	      conf_params := rec.GetSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 			     	      sub_conf_name  TEXT ) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  sub_conf_id INT;
	  crate_v INT[];
	  crate_id INT;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  SELECT SubConfigID( main_conf_name,sub_conf_name) INTO sub_conf_id;
	  SELECT ListEnabledCrates( main_conf_name, sub_conf_name ) INTO crate_v;
	  FOREACH crate_id IN ARRAY crate_v LOOP
	    FOR rec in SELECT GetCrateSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id) LOOP
	      conf_params := rec.GetCrateSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertMainConfiguration( subconfigparameters HSTORE,
	       	  	  	   			    subconfigmasks HSTORE,
	       	  	  	   			    confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
	    myrec2 RECORD;
	    myrec3 RECORD;
	    ColumnPair RECORD;
	    SubConfigCount INT;
	    -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    SubConfT INT;
	    --mainconfigexists INT;
	    localconfigexists INT;
	    BEGIN    
	
	    -- 1st CHECK: check if the provided Config ID already exsits in the MainConfigTable or not
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
		RETURN -1;
	    END IF;
	    -- now we know that the name doesn't exist or the user doesn't care.
	
	    -- 2nd CHECK: check if specified SubConfigType and SubConfigID are available or not
	    FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        -- Check if SubConfigType is valid or not
	        --        RAISE NOTICE 'key:%, value: %', ColumnPair.key, ColumnPair.value;
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
		    RETURN 1;
		END IF;
		-- Check if SubConfigID is valid or not
		query := format('SELECT TRUE FROM %s WHERE ConfigID=%s',ColumnPair.key,ColumnPair.value);
		EXECUTE query INTO myrec2;
		IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
		    RETURN 1;
		END IF;
		
	    END LOOP;
	    -- 3rd CHECK: subconfigmasks HSTORE keys has to be a subset of subconfigparameters HSTORE, and values must be BIGINT compatible type
	    IF NOT AKEYS(subconfigparameters) @> AKEYS(subconfigmasks) THEN
	      RAISE EXCEPTION '++++++++++++++ Mask contains configuration that is not in the list of subconfigurations! +++++++++++++';
	    END IF;
	
	    FOR ColumnPair IN SELECT (each(subconfigmasks)).*
	    LOOP
		SELECT textregexeq(ColumnPair.value,'^[0-1]+(\.[0-1]+)?$') AS VAL INTO myrec2;
		IF NOT myrec2.VAL THEN
		  RAISE EXCEPTION '++++++++++++ Config % Mask % is not a valid binary expression +++++++++++++',ColumnPair.key,ColumnPair.value;
		END IF;
	    END LOOP;
	
	    -- mainconfigexists:=1;  -- assuming it exists. Let's be proven otherwise.
	    --let's check if the configuration exists:
	    -- since we want to check the configuration sets, it's ok if we just choose the first subconfigtype and ID.
	    -- and then we loop over all of the subsets of MainconfigTable to see if they contain all of the other ones.
	
	    -- !!! Still missing. Find that the configuration we havefound does not have more rows than we need. !!!
	
	
	    SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;  -- only use the first.
	    --get subconfig type
	    ------------------------------ this repeats the functionality from later.
	
	    SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	    --looping over all mainconfigs that have the above parameters. 
	    for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	
	         -- Report
	--         RAISE NOTICE 'Checking against Main Config ID %', myrec3;
	
		 -- First check the # of sub-config types in this configuration. If not same as the # elements in subconfigparameters, continue.
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
	--	 SubConfigCount := SubConfigCount - ARRAY_LENGTH(AKEYS(subconfigparameters));
	--	 SELECT COUNT(TRUE) - SubConfigCount FROM 
	--	 IF SubConfigCount = 0
		 IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
		 END IF;
	
	         -- loop over all of the new, to be insterted config setting and check if the current configID has them all.
	         localconfigexists := 1;
		 for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	             IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
			  EXIT;   -- break out of loop. We already know, this is not the right config.
		     END IF;
	             END LOOP;
	         IF localconfigexists = 1    -- we've gone through all of the PMT settings and all exist.
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
		    RETURN -1;
		 END IF;
	     END LOOP;  -- end of myrec3 FOR loop over all of the subconfigs
	
	
	--     IF mainconfigexists = 1
	--       THEN RAISE EXCEPTION '+++++++++++++ Config already exists in MainConfigTable, with ID: %! +++++++++++++',-1;
	--     END IF;
	   ----------- To be improved
	   --------------------------------- Find the last entry
	    SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
	    IF newconfig IS NULL
	      THEN  newconfig := 0;
	    ELSE
	       newconfig := newconfig + 1;
	    END IF;
	    
	    RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
	   
	    -- Reaching this point means input values are valid. Let's insert.
	   FOR myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
	    SELECT subconfigmasks->myrec1.key AS VAL INTO myrec2;
	    IF myrec2.VAL IS NULL THEN
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      '111111111111'::BIT(64),
					      confname);
	    ELSE
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      CAST(myrec2.VAL AS BIT(64)),
					      confname);
	    END IF;
	
	    END LOOP;
	
	   RETURN newconfig;
	   END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
	    conftype ConfigLookUp.SubConfigType%TYPE;
	    mainconfrow mainconfigtable%ROWTYPE; --.subconfigparentid%TYPE;
	    subconfigconfigrec subconfigreturntype;
	    query   text;
	    testquery text;
	    mainconfquery text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', tablename;
	
	       --'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || subconfigid ;
	      testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
	      RAISE INFO 'testquery % ', testquery;
	      EXECUTE testquery INTO conftype;
	
	      RAISE INFO 'SELECTED % ', conftype;
	
	      mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || ' AND configid='||mainconfigid;  
	
	      RAISE INFO ' % ', mainconfquery ;
	   
	      EXECUTE mainconfquery INTO mainconfrow;
	
	      RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
	  
	  ---- SELECT   
	      query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
	
	      for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;  --inserting the name for faster lookup later
	      subconfigconfigrec.ConfigType:=conftype;   --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	      end loop;
	      return;
	
	     -- RAISE INFO ' % ', query ;
	
	     -- EXECUTE query INTO myrec; 
	     -- IF myrec.parameterx IS NULL  THEN
		--  RAISE EXCEPTION 'Configuration % not found', subconfigid;
	     -- END IF;
	
	--- SELECT PARENT, THEN SELECT INTO RECORD the STANDARD CONFIG WHERE MODULEID
	--- DO we want to get the ultimate Parent?
	--- This means that the flattened parent needs to have a -1? 
	--- need to keep a list of previous parents when looping
	
	
	
	--      query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	-- 
	    --   RAISE INFO 'result? % ', myrec ;
	-- 
	--       EXECUTE query INTO myrec; 
	-- 	IF myrec.configid IS NULL  THEN
	-- 	  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
	-- 	END IF;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	       -- RETURN myrec;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  relation "configlookup" does not exist at character 105
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	   SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = SCfgName LIMIT 1
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigParameters(SCfgName TEXT) RETURNS SETOF TEXT AS $$
	   SELECT skeys(setupcolumns) FROM configlookup WHERE subconfigname = SCfgName
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 128
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigNameAndID() RETURNS SETOF RECORD AS $$
	       SELECT SubConfigName, SubConfigType FROM ConfigLookUp ORDER BY SubConfigType
	$$ LANGUAGE SQL;
ERROR:  invalid type name "ConfigLookUp.SubConfigName%TYPE" at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION mainconfigcheck() RETURNS trigger AS $mainconfigcheck$
	    DECLARE
	    myrec RECORD;
	    tablename ConfigLookUp.SubConfigName%TYPE;
	    query   text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', NEW.subconfigtype;
	
	      SELECT  configname FROM configtypes WHERE configtypes.configtype=NEW.subconfigtype INTO tablename;
	
	      RAISE INFO 'SELECTED % ', tablename;
	
	     
	   
	  --  
	    query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigid ;
	
	    RAISE INFO ' % ', query ;
	
	    EXECUTE query INTO myrec; 
	      IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Configuration % not found', NEW.subconfigid;
	      END IF;
	
	     query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	
	      RAISE INFO ' % ', query ;
	
	      EXECUTE query INTO myrec; 
		IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
		END IF;
	--       EXECUTE 'SELECT configid FROM '
	-- 	|| tablename 
	-- 	|| ' WHERE '
	-- 	|| tablename
	-- 	|| '.configid ='
	-- 	|| substring(NEW.subconfigid,1,1) 
	--       INTO myrec;
	      --SELECT INTO myrec * FROM mainconfigtable WHERE mainconfigtable.configid=NEW.configid;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	        RETURN NEW;
	    END;
	$mainconfigcheck$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION ReturnConfigurationByNumber(requestedConfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    mainconfrec RECORD;
	    configlookuprec RECORD;
	    subconfigconfigrec subconfigreturntype;
	    subconfigquery  text ;
	    BEGIN
	       
		--select subconfigTypes and their numbers from the MainConfigTable
	
	    FOR mainconfrec IN SELECT SubConfigType,SubConfigID,SubConfigParentID,SubConfigOnMask FROM MainConfigTable 
	    WHERE Configid=requestedConfigid LOOP
	
	    RAISE INFO ' subconfig Type: %, ID: %, SubConfigParentID: %,  ',mainconfrec.SubConfigType,mainconfrec.SubConfigID,mainconfrec.SubConfigParentID;
	 
	    -- querying the lookup table to find out, what it is that we're picking up from the subconfig table
	    SELECT INTO configlookuprec * FROM ConfigLookUp WHERE ConfigLookup.SubConfigType=mainconfrec.SubConfigType;
	
	    RAISE INFO ' config name: % and parameters: % ',configlookuprec.SubConfigName,configlookuprec.SetupColumns;
	
	    -- Create JOIN of Main config table and subtable and return that
	    subconfigquery := 'SELECT *  FROM ' || configlookuprec.SubConfigName || ' WHERE ' || configlookuprec.SubConfigName || 
		  '.ConfigID = '||mainconfrec.SubConfigID;
	
	    RAISE INFO 'sub conf query: %',subconfigquery;
	
	 
	    for subconfigconfigrec in EXECUTE subconfigquery loop
	       subconfigconfigrec.ConfigName:=configlookuprec.SubConfigName;  --inserting the name for faster lookup later
	       subconfigconfigrec.ConfigType:=mainconfrec.SubConfigType;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	    end loop;
	
	  END LOOP;
	
	  RETURN;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GETQUERY2(configtabletype text,insubconfid INT,inmodule INT,columns HSTORE) RETURNS TEXT AS $$
	DECLARE
	  query text;
	  BEGIN
	  
	  query := format('SELECT * FROM %s WHERE ConfigID=%s AND ModuleID=%s',configtabletype,insubconfid,inmodule);
	--  return query;
	--  SELECT query;
	  EXECUTE query;
	--  RETURN query;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewCrateConfiguration( config_name TEXT,
	     	      	 			            config_id   INT,
							    crate_id    INT,
							    slot_id     INT,
							    channel_id  INT,
							    params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewSubConfiguration( config_name TEXT,
	     	      	 			          config_id   INT,
							  crate_id    INT,
							  slot_id     INT,
							  channel_id  INT,
							  params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION CheckNewSubConfiguration( config_name TEXT,
	       	  	  	   			     config_id   INT,
							     crate_id    INT,
							     slot_id     INT,
							     channel_id  INT,
							     params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	    myrec RECORD;
	    newconfig INT;
	    query text;  
	    ColumnPair RECORD;
	  BEGIN
	
	 -- Check 0) Possible combination of crate_id, slot_id, and channel_id
	    IF crate_id < 0 AND NOT (crate_id = -1 OR crate_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Crate ID: % +++++++++++', crate_id;
	      RETURN 1;
	
	    ELSIF slot_id < 0 AND NOT (slot_id = -1 OR slot_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Slot ID: % +++++++++++', slot_id;
	      RETURN 1;
	
	    ELSIF channel_id < 0 AND NOT (channel_id = -1 OR channel_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Channel ID: % +++++++++++', channel_id;
	      RETURN 1;
	
	    ELSIF ((crate_id + channel_id + slot_id) < -1001) THEN
	      RAISE NOTICE '++++++++++ Duplicate -999 values among (crate,slot,channel)=(%,%,%) ++++++++++++', crate_id, slot_id, channel_id;
	      RETURN 1;
	
	    ELSIF channel_id = -999 AND (crate_id = -1  AND slot_id >= 0) THEN
	      RAISE NOTICE '++++++++++ Crate ID must be 0 or positive integer for a specific slot default channel! ++++++++++';
	      RETURN 1;
	
	    ELSIF slot_id = -999 AND  channel_id != -1 THEN
	      RAISE NOTICE '++++++++++ Channel ID must be -1 if Slot ID is -999! +++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -999 AND (slot_id >=0 OR channel_id >=0 ) THEN
	      RAISE NOTICE '++++++++++ Slot and Channel ID must be -1 for default Crate config (ID=-999) ++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -1 AND (slot_id >= 0 OR channel_id >= 0) THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (-1, %, %) not allowed! +++++++++++',slot_id,channel_id;
	      RETURN 1;
	
	    ELSIF crate_id >= 0 AND slot_id = -1 AND channel_id >= 0 THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (%, -1, %) not allowed! +++++++++++',crate_id,channel_id;
	      RETURN 1;
	
	    END IF;
	
	 -- Check 1) find if this configuration type exists. If not, don't do anything
	    IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	      RAISE NOTICE '++++++++++ Configuration % is not defined yet! +++++++++++', config_name;
	      RETURN 1;
	    END IF;
	
	 -- Check 2) find if this config ID is already defined or not. If not, don't do anything
	    query := format('SELECT 1 AS VAL FROM %s WHERE ConfigID=%s LIMIT 1;',config_name,config_id);
	    EXECUTE query INTO myrec;
	    IF myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ Configuration % with ID % is not defined yet! +++++++++++', config_name, config_id;
	      RETURN 1;
	    END IF;
	
	 -- Check 3) find if a config like this exists. If does, don't do anything
	    query := format('SELECT TRUE AS VAL FROM %s WHERE ConfigID=%s AND Crate=%s AND Slot=%s AND Channel=%s',config_name,config_id, crate_id, slot_id, channel_id);
	    EXECUTE query INTO myrec;
	    IF NOT myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ (ConfigID,Crate,Slot,Channel) = (%,%,%,%) already exists! ++++++++++', config_id, crate_id, slot_id, channel_id;
	      RETURN 1;
	    END IF;
	
	    -- INSERT HSTORE checking, i.e. for each(hstore from ConfigLookUp Table, check that hstore key exists). TBD.
	    --IF NOT EXISTS (SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtablename AND columns ?& AKEYS(SetUpColumns)) THEN
	      --RAISE NOTICE '++++++++++ Provided HSTORE columns are lacking necessary pieces! +++++++++++';
	      --RETURN 1;
	    --END IF;
	    RETURN 0;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertCrateConfiguration( config_name     TEXT,
	  	      	 	 	  		   config_id       INT,
	     	      	 	  			   crate_default   HSTORE, 
							   slot_default      HSTORE, 
							   channel_default HSTORE, 
							   crate_mask   BIT(64),
							   slot_mask    BIT(64),
							   channel_mask BIT(64)
							   );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertSubConfiguration( config_name     TEXT,
	  	      	 	 			 config_id       INT,
	     	      	 	 			 crate_default   HSTORE, 
							 slot_default      HSTORE, 
							 channel_default HSTORE, 
							 crate_mask   BIT(64),
							 slot_mask    BIT(64),
							 channel_mask BIT(64)
							 );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertSubConfiguration( config_name     TEXT,
	     	      	 	 			   config_id       INT,
	     	      	 	 			   crate_default   HSTORE, 
							   slot_default    HSTORE, 
	 						   channel_default HSTORE,
							   crate_mask   BIT(64) DEFAULT '111111111111111'::BIT(64),
							   slot_mask    BIT(64) DEFAULT '1111111111111111111111111111111111111111111111111111111111111111',
	 						   channel_mask BIT(64) DEFAULT '0'::BIT(64)
							   ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  myrec RECORD;
	  BEGIN
	
	  IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	    RAISE EXCEPTION '++++++++++ Configuration % does not exist! +++++++++++', config_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID=%s LIMIT 1',config_name,config_id);
	  EXECUTE query INTO myrec;
	  IF NOT myrec.bool IS NULL THEN
	    RAISE EXCEPTION '++++++++++ Configuration % with ID % is already defined! +++++++++++', config_name, config_id;
	  END IF;
	
	--  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-999,-1,'''||slot_default||''','''||slot_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-1,-999,'''||channel_default||''','''||channel_mask||''')';
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendCrateConfiguration( config_name TEXT,
	     	      	 	 			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendSubConfiguration( config_name TEXT,
	     	      	 	 			 config_id   INT,
							 crate_id    INT,
							 slot_id     INT,
							 channel_id  INT,
							 Mask        BIT(64),
							 params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION AppendSubConfiguration( config_name TEXT,
	       	  	  	   			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  rec   RECORD;
	  BEGIN
	  
	    SELECT CheckNewCrateConfiguration(config_name, config_id, crate_id, slot_id, channel_id, params) AS VAL INTO rec;
	    IF rec.VAL = 1 THEN
	      RAISE EXCEPTION '+++++++++ Invalid subconfiguration! Aborting +++++++++';
	    RETURN 1;
	  END IF;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||','||crate_id||','''||slot_id||''','''||channel_id||''','''||params||''','''||Mask||''')';
	  RAISE INFO '%', query;
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateConfig( sub_conf_name TEXT,
	     	      	 			   sub_conf_id   INT,
						   crate_id      INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  conf_params.Crate := crate_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate = %s OR Crate = -999) AND SLOT = -1 AND Channel = -1 ORDER BY Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotConfig( sub_conf_name TEXT,
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT,
						  slot_id       INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  slot_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id);
	
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetChannelConfig( sub_conf_name TEXT,
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT,
						     channel_id    INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  channel_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;
	  IF NOT ARRAY[channel_id] <@ channel_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot,Channel) = (%,%,%) is not enabled! ++++++++++++',crate_id,slot_id,channel_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	  conf_params.Channel := channel_id;
	  conf_params.Params  := '';  
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Channel = -999 OR (Crate = %s AND Slot = %s AND Channel = %s)) ORDER BY Channel ASC, Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id,
			   channel_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	 sub_conf_id   INT,
						     	 crate_id      INT,
						     	 slot_id       INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  params HSTORE;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  channel_v INT[];
	  channel_id INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN NEXT conf_params;
	  ELSE
	
	    conf_params.Crate   := crate_id;
	    conf_params.Slot    := slot_id;
	    conf_params.Channel := -1;
	    conf_params.Params  := '';
	
	    query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	     sub_conf_name,
			     sub_conf_id,
			     crate_id,
			     slot_id);
	
	    FOR rec IN EXECUTE query LOOP
	      conf_params.Params := conf_params.Params || rec.Parameters;
	    END LOOP;
	
	    RETURN NEXT conf_params;
	
	    SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;  
	    FOREACH channel_id IN ARRAY channel_v LOOP
	
	      SELECT GetChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id, channel_id) INTO rec;
	      
	      conf_params := rec.getchannelconfig;
	      
	      RETURN NEXT conf_params;
	    END LOOP;
	  END IF;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	      sub_conf_id   INT,
						     	      crate_id      INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  slot_id   INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  --SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO conf_params;
	  SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO rec;
	  conf_params := rec.getcrateconfig;
	  RETURN NEXT conf_params;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  FOREACH slot_id IN ARRAY slot_v LOOP
	    FOR rec IN SELECT GetSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id) LOOP
	      conf_params := rec.GetSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 			     	      sub_conf_name  TEXT ) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  sub_conf_id INT;
	  crate_v INT[];
	  crate_id INT;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  SELECT SubConfigID( main_conf_name,sub_conf_name) INTO sub_conf_id;
	  SELECT ListEnabledCrates( main_conf_name, sub_conf_name ) INTO crate_v;
	  FOREACH crate_id IN ARRAY crate_v LOOP
	    FOR rec in SELECT GetCrateSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id) LOOP
	      conf_params := rec.GetCrateSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertMainConfiguration( subconfigparameters HSTORE,
	       	  	  	   			    subconfigmasks HSTORE,
	       	  	  	   			    confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
	    myrec2 RECORD;
	    myrec3 RECORD;
	    ColumnPair RECORD;
	    SubConfigCount INT;
	    -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    SubConfT INT;
	    --mainconfigexists INT;
	    localconfigexists INT;
	    BEGIN    
	
	    -- 1st CHECK: check if the provided Config ID already exsits in the MainConfigTable or not
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
		RETURN -1;
	    END IF;
	    -- now we know that the name doesn't exist or the user doesn't care.
	
	    -- 2nd CHECK: check if specified SubConfigType and SubConfigID are available or not
	    FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        -- Check if SubConfigType is valid or not
	        --        RAISE NOTICE 'key:%, value: %', ColumnPair.key, ColumnPair.value;
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
		    RETURN 1;
		END IF;
		-- Check if SubConfigID is valid or not
		query := format('SELECT TRUE FROM %s WHERE ConfigID=%s',ColumnPair.key,ColumnPair.value);
		EXECUTE query INTO myrec2;
		IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
		    RETURN 1;
		END IF;
		
	    END LOOP;
	    -- 3rd CHECK: subconfigmasks HSTORE keys has to be a subset of subconfigparameters HSTORE, and values must be BIGINT compatible type
	    IF NOT AKEYS(subconfigparameters) @> AKEYS(subconfigmasks) THEN
	      RAISE EXCEPTION '++++++++++++++ Mask contains configuration that is not in the list of subconfigurations! +++++++++++++';
	    END IF;
	
	    FOR ColumnPair IN SELECT (each(subconfigmasks)).*
	    LOOP
		SELECT textregexeq(ColumnPair.value,'^[0-1]+(\.[0-1]+)?$') AS VAL INTO myrec2;
		IF NOT myrec2.VAL THEN
		  RAISE EXCEPTION '++++++++++++ Config % Mask % is not a valid binary expression +++++++++++++',ColumnPair.key,ColumnPair.value;
		END IF;
	    END LOOP;
	
	    -- mainconfigexists:=1;  -- assuming it exists. Let's be proven otherwise.
	    --let's check if the configuration exists:
	    -- since we want to check the configuration sets, it's ok if we just choose the first subconfigtype and ID.
	    -- and then we loop over all of the subsets of MainconfigTable to see if they contain all of the other ones.
	
	    -- !!! Still missing. Find that the configuration we havefound does not have more rows than we need. !!!
	
	
	    SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;  -- only use the first.
	    --get subconfig type
	    ------------------------------ this repeats the functionality from later.
	
	    SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	    --looping over all mainconfigs that have the above parameters. 
	    for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	
	         -- Report
	--         RAISE NOTICE 'Checking against Main Config ID %', myrec3;
	
		 -- First check the # of sub-config types in this configuration. If not same as the # elements in subconfigparameters, continue.
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
	--	 SubConfigCount := SubConfigCount - ARRAY_LENGTH(AKEYS(subconfigparameters));
	--	 SELECT COUNT(TRUE) - SubConfigCount FROM 
	--	 IF SubConfigCount = 0
		 IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
		 END IF;
	
	         -- loop over all of the new, to be insterted config setting and check if the current configID has them all.
	         localconfigexists := 1;
		 for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	             IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
			  EXIT;   -- break out of loop. We already know, this is not the right config.
		     END IF;
	             END LOOP;
	         IF localconfigexists = 1    -- we've gone through all of the PMT settings and all exist.
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
		    RETURN -1;
		 END IF;
	     END LOOP;  -- end of myrec3 FOR loop over all of the subconfigs
	
	
	--     IF mainconfigexists = 1
	--       THEN RAISE EXCEPTION '+++++++++++++ Config already exists in MainConfigTable, with ID: %! +++++++++++++',-1;
	--     END IF;
	   ----------- To be improved
	   --------------------------------- Find the last entry
	    SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
	    IF newconfig IS NULL
	      THEN  newconfig := 0;
	    ELSE
	       newconfig := newconfig + 1;
	    END IF;
	    
	    RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
	   
	    -- Reaching this point means input values are valid. Let's insert.
	   FOR myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
	    SELECT subconfigmasks->myrec1.key AS VAL INTO myrec2;
	    IF myrec2.VAL IS NULL THEN
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      '111111111111'::BIT(64),
					      confname);
	    ELSE
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      CAST(myrec2.VAL AS BIT(64)),
					      confname);
	    END IF;
	
	    END LOOP;
	
	   RETURN newconfig;
	   END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
	    conftype ConfigLookUp.SubConfigType%TYPE;
	    mainconfrow mainconfigtable%ROWTYPE; --.subconfigparentid%TYPE;
	    subconfigconfigrec subconfigreturntype;
	    query   text;
	    testquery text;
	    mainconfquery text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', tablename;
	
	       --'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || subconfigid ;
	      testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
	      RAISE INFO 'testquery % ', testquery;
	      EXECUTE testquery INTO conftype;
	
	      RAISE INFO 'SELECTED % ', conftype;
	
	      mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || ' AND configid='||mainconfigid;  
	
	      RAISE INFO ' % ', mainconfquery ;
	   
	      EXECUTE mainconfquery INTO mainconfrow;
	
	      RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
	  
	  ---- SELECT   
	      query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
	
	      for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;  --inserting the name for faster lookup later
	      subconfigconfigrec.ConfigType:=conftype;   --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	      end loop;
	      return;
	
	     -- RAISE INFO ' % ', query ;
	
	     -- EXECUTE query INTO myrec; 
	     -- IF myrec.parameterx IS NULL  THEN
		--  RAISE EXCEPTION 'Configuration % not found', subconfigid;
	     -- END IF;
	
	--- SELECT PARENT, THEN SELECT INTO RECORD the STANDARD CONFIG WHERE MODULEID
	--- DO we want to get the ultimate Parent?
	--- This means that the flattened parent needs to have a -1? 
	--- need to keep a list of previous parents when looping
	
	
	
	--      query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	-- 
	    --   RAISE INFO 'result? % ', myrec ;
	-- 
	--       EXECUTE query INTO myrec; 
	-- 	IF myrec.configid IS NULL  THEN
	-- 	  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
	-- 	END IF;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	       -- RETURN myrec;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  relation "configlookup" does not exist at character 105
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	   SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = SCfgName LIMIT 1
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigParameters(SCfgName TEXT) RETURNS SETOF TEXT AS $$
	   SELECT skeys(setupcolumns) FROM configlookup WHERE subconfigname = SCfgName
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 128
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigNameAndID() RETURNS SETOF RECORD AS $$
	       SELECT SubConfigName, SubConfigType FROM ConfigLookUp ORDER BY SubConfigType
	$$ LANGUAGE SQL;
ERROR:  invalid type name "ConfigLookUp.SubConfigName%TYPE" at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION mainconfigcheck() RETURNS trigger AS $mainconfigcheck$
	    DECLARE
	    myrec RECORD;
	    tablename ConfigLookUp.SubConfigName%TYPE;
	    query   text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', NEW.subconfigtype;
	
	      SELECT  configname FROM configtypes WHERE configtypes.configtype=NEW.subconfigtype INTO tablename;
	
	      RAISE INFO 'SELECTED % ', tablename;
	
	     
	   
	  --  
	    query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigid ;
	
	    RAISE INFO ' % ', query ;
	
	    EXECUTE query INTO myrec; 
	      IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Configuration % not found', NEW.subconfigid;
	      END IF;
	
	     query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	
	      RAISE INFO ' % ', query ;
	
	      EXECUTE query INTO myrec; 
		IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
		END IF;
	--       EXECUTE 'SELECT configid FROM '
	-- 	|| tablename 
	-- 	|| ' WHERE '
	-- 	|| tablename
	-- 	|| '.configid ='
	-- 	|| substring(NEW.subconfigid,1,1) 
	--       INTO myrec;
	      --SELECT INTO myrec * FROM mainconfigtable WHERE mainconfigtable.configid=NEW.configid;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	        RETURN NEW;
	    END;
	$mainconfigcheck$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION ReturnConfigurationByNumber(requestedConfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    mainconfrec RECORD;
	    configlookuprec RECORD;
	    subconfigconfigrec subconfigreturntype;
	    subconfigquery  text ;
	    BEGIN
	       
		--select subconfigTypes and their numbers from the MainConfigTable
	
	    FOR mainconfrec IN SELECT SubConfigType,SubConfigID,SubConfigParentID,SubConfigOnMask FROM MainConfigTable 
	    WHERE Configid=requestedConfigid LOOP
	
	    RAISE INFO ' subconfig Type: %, ID: %, SubConfigParentID: %,  ',mainconfrec.SubConfigType,mainconfrec.SubConfigID,mainconfrec.SubConfigParentID;
	 
	    -- querying the lookup table to find out, what it is that we're picking up from the subconfig table
	    SELECT INTO configlookuprec * FROM ConfigLookUp WHERE ConfigLookup.SubConfigType=mainconfrec.SubConfigType;
	
	    RAISE INFO ' config name: % and parameters: % ',configlookuprec.SubConfigName,configlookuprec.SetupColumns;
	
	    -- Create JOIN of Main config table and subtable and return that
	    subconfigquery := 'SELECT *  FROM ' || configlookuprec.SubConfigName || ' WHERE ' || configlookuprec.SubConfigName || 
		  '.ConfigID = '||mainconfrec.SubConfigID;
	
	    RAISE INFO 'sub conf query: %',subconfigquery;
	
	 
	    for subconfigconfigrec in EXECUTE subconfigquery loop
	       subconfigconfigrec.ConfigName:=configlookuprec.SubConfigName;  --inserting the name for faster lookup later
	       subconfigconfigrec.ConfigType:=mainconfrec.SubConfigType;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	    end loop;
	
	  END LOOP;
	
	  RETURN;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GETQUERY2(configtabletype text,insubconfid INT,inmodule INT,columns HSTORE) RETURNS TEXT AS $$
	DECLARE
	  query text;
	  BEGIN
	  
	  query := format('SELECT * FROM %s WHERE ConfigID=%s AND ModuleID=%s',configtabletype,insubconfid,inmodule);
	--  return query;
	--  SELECT query;
	  EXECUTE query;
	--  RETURN query;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewCrateConfiguration( config_name TEXT,
	     	      	 			            config_id   INT,
							    crate_id    INT,
							    slot_id     INT,
							    channel_id  INT,
							    params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewSubConfiguration( config_name TEXT,
	     	      	 			          config_id   INT,
							  crate_id    INT,
							  slot_id     INT,
							  channel_id  INT,
							  params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION CheckNewSubConfiguration( config_name TEXT,
	       	  	  	   			     config_id   INT,
							     crate_id    INT,
							     slot_id     INT,
							     channel_id  INT,
							     params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	    myrec RECORD;
	    newconfig INT;
	    query text;  
	    ColumnPair RECORD;
	  BEGIN
	
	 -- Check 0) Possible combination of crate_id, slot_id, and channel_id
	    IF crate_id < 0 AND NOT (crate_id = -1 OR crate_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Crate ID: % +++++++++++', crate_id;
	      RETURN 1;
	
	    ELSIF slot_id < 0 AND NOT (slot_id = -1 OR slot_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Slot ID: % +++++++++++', slot_id;
	      RETURN 1;
	
	    ELSIF channel_id < 0 AND NOT (channel_id = -1 OR channel_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Channel ID: % +++++++++++', channel_id;
	      RETURN 1;
	
	    ELSIF ((crate_id + channel_id + slot_id) < -1001) THEN
	      RAISE NOTICE '++++++++++ Duplicate -999 values among (crate,slot,channel)=(%,%,%) ++++++++++++', crate_id, slot_id, channel_id;
	      RETURN 1;
	
	    ELSIF channel_id = -999 AND (crate_id = -1  AND slot_id >= 0) THEN
	      RAISE NOTICE '++++++++++ Crate ID must be 0 or positive integer for a specific slot default channel! ++++++++++';
	      RETURN 1;
	
	    ELSIF slot_id = -999 AND  channel_id != -1 THEN
	      RAISE NOTICE '++++++++++ Channel ID must be -1 if Slot ID is -999! +++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -999 AND (slot_id >=0 OR channel_id >=0 ) THEN
	      RAISE NOTICE '++++++++++ Slot and Channel ID must be -1 for default Crate config (ID=-999) ++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -1 AND (slot_id >= 0 OR channel_id >= 0) THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (-1, %, %) not allowed! +++++++++++',slot_id,channel_id;
	      RETURN 1;
	
	    ELSIF crate_id >= 0 AND slot_id = -1 AND channel_id >= 0 THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (%, -1, %) not allowed! +++++++++++',crate_id,channel_id;
	      RETURN 1;
	
	    END IF;
	
	 -- Check 1) find if this configuration type exists. If not, don't do anything
	    IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	      RAISE NOTICE '++++++++++ Configuration % is not defined yet! +++++++++++', config_name;
	      RETURN 1;
	    END IF;
	
	 -- Check 2) find if this config ID is already defined or not. If not, don't do anything
	    query := format('SELECT 1 AS VAL FROM %s WHERE ConfigID=%s LIMIT 1;',config_name,config_id);
	    EXECUTE query INTO myrec;
	    IF myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ Configuration % with ID % is not defined yet! +++++++++++', config_name, config_id;
	      RETURN 1;
	    END IF;
	
	 -- Check 3) find if a config like this exists. If does, don't do anything
	    query := format('SELECT TRUE AS VAL FROM %s WHERE ConfigID=%s AND Crate=%s AND Slot=%s AND Channel=%s',config_name,config_id, crate_id, slot_id, channel_id);
	    EXECUTE query INTO myrec;
	    IF NOT myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ (ConfigID,Crate,Slot,Channel) = (%,%,%,%) already exists! ++++++++++', config_id, crate_id, slot_id, channel_id;
	      RETURN 1;
	    END IF;
	
	    -- INSERT HSTORE checking, i.e. for each(hstore from ConfigLookUp Table, check that hstore key exists). TBD.
	    --IF NOT EXISTS (SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtablename AND columns ?& AKEYS(SetUpColumns)) THEN
	      --RAISE NOTICE '++++++++++ Provided HSTORE columns are lacking necessary pieces! +++++++++++';
	      --RETURN 1;
	    --END IF;
	    RETURN 0;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertCrateConfiguration( config_name     TEXT,
	  	      	 	 	  		   config_id       INT,
	     	      	 	  			   crate_default   HSTORE, 
							   slot_default      HSTORE, 
							   channel_default HSTORE, 
							   crate_mask   BIT(64),
							   slot_mask    BIT(64),
							   channel_mask BIT(64)
							   );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertSubConfiguration( config_name     TEXT,
	  	      	 	 			 config_id       INT,
	     	      	 	 			 crate_default   HSTORE, 
							 slot_default      HSTORE, 
							 channel_default HSTORE, 
							 crate_mask   BIT(64),
							 slot_mask    BIT(64),
							 channel_mask BIT(64)
							 );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertSubConfiguration( config_name     TEXT,
	     	      	 	 			   config_id       INT,
	     	      	 	 			   crate_default   HSTORE, 
							   slot_default    HSTORE, 
	 						   channel_default HSTORE,
							   crate_mask   BIT(64) DEFAULT '111111111111111'::BIT(64),
							   slot_mask    BIT(64) DEFAULT '1111111111111111111111111111111111111111111111111111111111111111',
	 						   channel_mask BIT(64) DEFAULT '0'::BIT(64)
							   ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  myrec RECORD;
	  BEGIN
	
	  IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	    RAISE EXCEPTION '++++++++++ Configuration % does not exist! +++++++++++', config_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID=%s LIMIT 1',config_name,config_id);
	  EXECUTE query INTO myrec;
	  IF NOT myrec.bool IS NULL THEN
	    RAISE EXCEPTION '++++++++++ Configuration % with ID % is already defined! +++++++++++', config_name, config_id;
	  END IF;
	
	--  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-999,-1,'''||slot_default||''','''||slot_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-1,-999,'''||channel_default||''','''||channel_mask||''')';
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendCrateConfiguration( config_name TEXT,
	     	      	 	 			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendSubConfiguration( config_name TEXT,
	     	      	 	 			 config_id   INT,
							 crate_id    INT,
							 slot_id     INT,
							 channel_id  INT,
							 Mask        BIT(64),
							 params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION AppendSubConfiguration( config_name TEXT,
	       	  	  	   			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  rec   RECORD;
	  BEGIN
	  
	    SELECT CheckNewCrateConfiguration(config_name, config_id, crate_id, slot_id, channel_id, params) AS VAL INTO rec;
	    IF rec.VAL = 1 THEN
	      RAISE EXCEPTION '+++++++++ Invalid subconfiguration! Aborting +++++++++';
	    RETURN 1;
	  END IF;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||','||crate_id||','''||slot_id||''','''||channel_id||''','''||params||''','''||Mask||''')';
	  RAISE INFO '%', query;
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateConfig( sub_conf_name TEXT,
	     	      	 			   sub_conf_id   INT,
						   crate_id      INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  conf_params.Crate := crate_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate = %s OR Crate = -999) AND SLOT = -1 AND Channel = -1 ORDER BY Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotConfig( sub_conf_name TEXT,
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT,
						  slot_id       INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  slot_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id);
	
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetChannelConfig( sub_conf_name TEXT,
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT,
						     channel_id    INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  channel_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;
	  IF NOT ARRAY[channel_id] <@ channel_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot,Channel) = (%,%,%) is not enabled! ++++++++++++',crate_id,slot_id,channel_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	  conf_params.Channel := channel_id;
	  conf_params.Params  := '';  
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Channel = -999 OR (Crate = %s AND Slot = %s AND Channel = %s)) ORDER BY Channel ASC, Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id,
			   channel_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	 sub_conf_id   INT,
						     	 crate_id      INT,
						     	 slot_id       INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  params HSTORE;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  channel_v INT[];
	  channel_id INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN NEXT conf_params;
	  ELSE
	
	    conf_params.Crate   := crate_id;
	    conf_params.Slot    := slot_id;
	    conf_params.Channel := -1;
	    conf_params.Params  := '';
	
	    query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	     sub_conf_name,
			     sub_conf_id,
			     crate_id,
			     slot_id);
	
	    FOR rec IN EXECUTE query LOOP
	      conf_params.Params := conf_params.Params || rec.Parameters;
	    END LOOP;
	
	    RETURN NEXT conf_params;
	
	    SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;  
	    FOREACH channel_id IN ARRAY channel_v LOOP
	
	      SELECT GetChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id, channel_id) INTO rec;
	      
	      conf_params := rec.getchannelconfig;
	      
	      RETURN NEXT conf_params;
	    END LOOP;
	  END IF;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	      sub_conf_id   INT,
						     	      crate_id      INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  slot_id   INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  --SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO conf_params;
	  SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO rec;
	  conf_params := rec.getcrateconfig;
	  RETURN NEXT conf_params;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  FOREACH slot_id IN ARRAY slot_v LOOP
	    FOR rec IN SELECT GetSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id) LOOP
	      conf_params := rec.GetSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 			     	      sub_conf_name  TEXT ) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  sub_conf_id INT;
	  crate_v INT[];
	  crate_id INT;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  SELECT SubConfigID( main_conf_name,sub_conf_name) INTO sub_conf_id;
	  SELECT ListEnabledCrates( main_conf_name, sub_conf_name ) INTO crate_v;
	  FOREACH crate_id IN ARRAY crate_v LOOP
	    FOR rec in SELECT GetCrateSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id) LOOP
	      conf_params := rec.GetCrateSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertMainConfiguration( subconfigparameters HSTORE,
	       	  	  	   			    subconfigmasks HSTORE,
	       	  	  	   			    confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
	    myrec2 RECORD;
	    myrec3 RECORD;
	    ColumnPair RECORD;
	    SubConfigCount INT;
	    -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    SubConfT INT;
	    --mainconfigexists INT;
	    localconfigexists INT;
	    BEGIN    
	
	    -- 1st CHECK: check if the provided Config ID already exsits in the MainConfigTable or not
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
		RETURN -1;
	    END IF;
	    -- now we know that the name doesn't exist or the user doesn't care.
	
	    -- 2nd CHECK: check if specified SubConfigType and SubConfigID are available or not
	    FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        -- Check if SubConfigType is valid or not
	        --        RAISE NOTICE 'key:%, value: %', ColumnPair.key, ColumnPair.value;
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
		    RETURN 1;
		END IF;
		-- Check if SubConfigID is valid or not
		query := format('SELECT TRUE FROM %s WHERE ConfigID=%s',ColumnPair.key,ColumnPair.value);
		EXECUTE query INTO myrec2;
		IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
		    RETURN 1;
		END IF;
		
	    END LOOP;
	    -- 3rd CHECK: subconfigmasks HSTORE keys has to be a subset of subconfigparameters HSTORE, and values must be BIGINT compatible type
	    IF NOT AKEYS(subconfigparameters) @> AKEYS(subconfigmasks) THEN
	      RAISE EXCEPTION '++++++++++++++ Mask contains configuration that is not in the list of subconfigurations! +++++++++++++';
	    END IF;
	
	    FOR ColumnPair IN SELECT (each(subconfigmasks)).*
	    LOOP
		SELECT textregexeq(ColumnPair.value,'^[0-1]+(\.[0-1]+)?$') AS VAL INTO myrec2;
		IF NOT myrec2.VAL THEN
		  RAISE EXCEPTION '++++++++++++ Config % Mask % is not a valid binary expression +++++++++++++',ColumnPair.key,ColumnPair.value;
		END IF;
	    END LOOP;
	
	    -- mainconfigexists:=1;  -- assuming it exists. Let's be proven otherwise.
	    --let's check if the configuration exists:
	    -- since we want to check the configuration sets, it's ok if we just choose the first subconfigtype and ID.
	    -- and then we loop over all of the subsets of MainconfigTable to see if they contain all of the other ones.
	
	    -- !!! Still missing. Find that the configuration we havefound does not have more rows than we need. !!!
	
	
	    SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;  -- only use the first.
	    --get subconfig type
	    ------------------------------ this repeats the functionality from later.
	
	    SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	    --looping over all mainconfigs that have the above parameters. 
	    for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	
	         -- Report
	--         RAISE NOTICE 'Checking against Main Config ID %', myrec3;
	
		 -- First check the # of sub-config types in this configuration. If not same as the # elements in subconfigparameters, continue.
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
	--	 SubConfigCount := SubConfigCount - ARRAY_LENGTH(AKEYS(subconfigparameters));
	--	 SELECT COUNT(TRUE) - SubConfigCount FROM 
	--	 IF SubConfigCount = 0
		 IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
		 END IF;
	
	         -- loop over all of the new, to be insterted config setting and check if the current configID has them all.
	         localconfigexists := 1;
		 for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	             IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
			  EXIT;   -- break out of loop. We already know, this is not the right config.
		     END IF;
	             END LOOP;
	         IF localconfigexists = 1    -- we've gone through all of the PMT settings and all exist.
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
		    RETURN -1;
		 END IF;
	     END LOOP;  -- end of myrec3 FOR loop over all of the subconfigs
	
	
	--     IF mainconfigexists = 1
	--       THEN RAISE EXCEPTION '+++++++++++++ Config already exists in MainConfigTable, with ID: %! +++++++++++++',-1;
	--     END IF;
	   ----------- To be improved
	   --------------------------------- Find the last entry
	    SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
	    IF newconfig IS NULL
	      THEN  newconfig := 0;
	    ELSE
	       newconfig := newconfig + 1;
	    END IF;
	    
	    RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
	   
	    -- Reaching this point means input values are valid. Let's insert.
	   FOR myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
	    SELECT subconfigmasks->myrec1.key AS VAL INTO myrec2;
	    IF myrec2.VAL IS NULL THEN
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      '111111111111'::BIT(64),
					      confname);
	    ELSE
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      CAST(myrec2.VAL AS BIT(64)),
					      confname);
	    END IF;
	
	    END LOOP;
	
	   RETURN newconfig;
	   END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
	    conftype ConfigLookUp.SubConfigType%TYPE;
	    mainconfrow mainconfigtable%ROWTYPE; --.subconfigparentid%TYPE;
	    subconfigconfigrec subconfigreturntype;
	    query   text;
	    testquery text;
	    mainconfquery text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', tablename;
	
	       --'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || subconfigid ;
	      testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
	      RAISE INFO 'testquery % ', testquery;
	      EXECUTE testquery INTO conftype;
	
	      RAISE INFO 'SELECTED % ', conftype;
	
	      mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || ' AND configid='||mainconfigid;  
	
	      RAISE INFO ' % ', mainconfquery ;
	   
	      EXECUTE mainconfquery INTO mainconfrow;
	
	      RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
	  
	  ---- SELECT   
	      query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
	
	      for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;  --inserting the name for faster lookup later
	      subconfigconfigrec.ConfigType:=conftype;   --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	      end loop;
	      return;
	
	     -- RAISE INFO ' % ', query ;
	
	     -- EXECUTE query INTO myrec; 
	     -- IF myrec.parameterx IS NULL  THEN
		--  RAISE EXCEPTION 'Configuration % not found', subconfigid;
	     -- END IF;
	
	--- SELECT PARENT, THEN SELECT INTO RECORD the STANDARD CONFIG WHERE MODULEID
	--- DO we want to get the ultimate Parent?
	--- This means that the flattened parent needs to have a -1? 
	--- need to keep a list of previous parents when looping
	
	
	
	--      query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	-- 
	    --   RAISE INFO 'result? % ', myrec ;
	-- 
	--       EXECUTE query INTO myrec; 
	-- 	IF myrec.configid IS NULL  THEN
	-- 	  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
	-- 	END IF;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	       -- RETURN myrec;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  relation "configlookup" does not exist at character 105
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	   SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = SCfgName LIMIT 1
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigParameters(SCfgName TEXT) RETURNS SETOF TEXT AS $$
	   SELECT skeys(setupcolumns) FROM configlookup WHERE subconfigname = SCfgName
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 128
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigNameAndID() RETURNS SETOF RECORD AS $$
	       SELECT SubConfigName, SubConfigType FROM ConfigLookUp ORDER BY SubConfigType
	$$ LANGUAGE SQL;
ERROR:  invalid type name "ConfigLookUp.SubConfigName%TYPE" at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION mainconfigcheck() RETURNS trigger AS $mainconfigcheck$
	    DECLARE
	    myrec RECORD;
	    tablename ConfigLookUp.SubConfigName%TYPE;
	    query   text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', NEW.subconfigtype;
	
	      SELECT  configname FROM configtypes WHERE configtypes.configtype=NEW.subconfigtype INTO tablename;
	
	      RAISE INFO 'SELECTED % ', tablename;
	
	     
	   
	  --  
	    query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigid ;
	
	    RAISE INFO ' % ', query ;
	
	    EXECUTE query INTO myrec; 
	      IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Configuration % not found', NEW.subconfigid;
	      END IF;
	
	     query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	
	      RAISE INFO ' % ', query ;
	
	      EXECUTE query INTO myrec; 
		IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
		END IF;
	--       EXECUTE 'SELECT configid FROM '
	-- 	|| tablename 
	-- 	|| ' WHERE '
	-- 	|| tablename
	-- 	|| '.configid ='
	-- 	|| substring(NEW.subconfigid,1,1) 
	--       INTO myrec;
	      --SELECT INTO myrec * FROM mainconfigtable WHERE mainconfigtable.configid=NEW.configid;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	        RETURN NEW;
	    END;
	$mainconfigcheck$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION ReturnConfigurationByNumber(requestedConfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    mainconfrec RECORD;
	    configlookuprec RECORD;
	    subconfigconfigrec subconfigreturntype;
	    subconfigquery  text ;
	    BEGIN
	       
		--select subconfigTypes and their numbers from the MainConfigTable
	
	    FOR mainconfrec IN SELECT SubConfigType,SubConfigID,SubConfigParentID,SubConfigOnMask FROM MainConfigTable 
	    WHERE Configid=requestedConfigid LOOP
	
	    RAISE INFO ' subconfig Type: %, ID: %, SubConfigParentID: %,  ',mainconfrec.SubConfigType,mainconfrec.SubConfigID,mainconfrec.SubConfigParentID;
	 
	    -- querying the lookup table to find out, what it is that we're picking up from the subconfig table
	    SELECT INTO configlookuprec * FROM ConfigLookUp WHERE ConfigLookup.SubConfigType=mainconfrec.SubConfigType;
	
	    RAISE INFO ' config name: % and parameters: % ',configlookuprec.SubConfigName,configlookuprec.SetupColumns;
	
	    -- Create JOIN of Main config table and subtable and return that
	    subconfigquery := 'SELECT *  FROM ' || configlookuprec.SubConfigName || ' WHERE ' || configlookuprec.SubConfigName || 
		  '.ConfigID = '||mainconfrec.SubConfigID;
	
	    RAISE INFO 'sub conf query: %',subconfigquery;
	
	 
	    for subconfigconfigrec in EXECUTE subconfigquery loop
	       subconfigconfigrec.ConfigName:=configlookuprec.SubConfigName;  --inserting the name for faster lookup later
	       subconfigconfigrec.ConfigType:=mainconfrec.SubConfigType;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	    end loop;
	
	  END LOOP;
	
	  RETURN;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GETQUERY2(configtabletype text,insubconfid INT,inmodule INT,columns HSTORE) RETURNS TEXT AS $$
	DECLARE
	  query text;
	  BEGIN
	  
	  query := format('SELECT * FROM %s WHERE ConfigID=%s AND ModuleID=%s',configtabletype,insubconfid,inmodule);
	--  return query;
	--  SELECT query;
	  EXECUTE query;
	--  RETURN query;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewCrateConfiguration( config_name TEXT,
	     	      	 			            config_id   INT,
							    crate_id    INT,
							    slot_id     INT,
							    channel_id  INT,
							    params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewSubConfiguration( config_name TEXT,
	     	      	 			          config_id   INT,
							  crate_id    INT,
							  slot_id     INT,
							  channel_id  INT,
							  params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION CheckNewSubConfiguration( config_name TEXT,
	       	  	  	   			     config_id   INT,
							     crate_id    INT,
							     slot_id     INT,
							     channel_id  INT,
							     params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	    myrec RECORD;
	    newconfig INT;
	    query text;  
	    ColumnPair RECORD;
	  BEGIN
	
	 -- Check 0) Possible combination of crate_id, slot_id, and channel_id
	    IF crate_id < 0 AND NOT (crate_id = -1 OR crate_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Crate ID: % +++++++++++', crate_id;
	      RETURN 1;
	
	    ELSIF slot_id < 0 AND NOT (slot_id = -1 OR slot_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Slot ID: % +++++++++++', slot_id;
	      RETURN 1;
	
	    ELSIF channel_id < 0 AND NOT (channel_id = -1 OR channel_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Channel ID: % +++++++++++', channel_id;
	      RETURN 1;
	
	    ELSIF ((crate_id + channel_id + slot_id) < -1001) THEN
	      RAISE NOTICE '++++++++++ Duplicate -999 values among (crate,slot,channel)=(%,%,%) ++++++++++++', crate_id, slot_id, channel_id;
	      RETURN 1;
	
	    ELSIF channel_id = -999 AND (crate_id = -1  AND slot_id >= 0) THEN
	      RAISE NOTICE '++++++++++ Crate ID must be 0 or positive integer for a specific slot default channel! ++++++++++';
	      RETURN 1;
	
	    ELSIF slot_id = -999 AND  channel_id != -1 THEN
	      RAISE NOTICE '++++++++++ Channel ID must be -1 if Slot ID is -999! +++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -999 AND (slot_id >=0 OR channel_id >=0 ) THEN
	      RAISE NOTICE '++++++++++ Slot and Channel ID must be -1 for default Crate config (ID=-999) ++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -1 AND (slot_id >= 0 OR channel_id >= 0) THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (-1, %, %) not allowed! +++++++++++',slot_id,channel_id;
	      RETURN 1;
	
	    ELSIF crate_id >= 0 AND slot_id = -1 AND channel_id >= 0 THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (%, -1, %) not allowed! +++++++++++',crate_id,channel_id;
	      RETURN 1;
	
	    END IF;
	
	 -- Check 1) find if this configuration type exists. If not, don't do anything
	    IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	      RAISE NOTICE '++++++++++ Configuration % is not defined yet! +++++++++++', config_name;
	      RETURN 1;
	    END IF;
	
	 -- Check 2) find if this config ID is already defined or not. If not, don't do anything
	    query := format('SELECT 1 AS VAL FROM %s WHERE ConfigID=%s LIMIT 1;',config_name,config_id);
	    EXECUTE query INTO myrec;
	    IF myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ Configuration % with ID % is not defined yet! +++++++++++', config_name, config_id;
	      RETURN 1;
	    END IF;
	
	 -- Check 3) find if a config like this exists. If does, don't do anything
	    query := format('SELECT TRUE AS VAL FROM %s WHERE ConfigID=%s AND Crate=%s AND Slot=%s AND Channel=%s',config_name,config_id, crate_id, slot_id, channel_id);
	    EXECUTE query INTO myrec;
	    IF NOT myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ (ConfigID,Crate,Slot,Channel) = (%,%,%,%) already exists! ++++++++++', config_id, crate_id, slot_id, channel_id;
	      RETURN 1;
	    END IF;
	
	    -- INSERT HSTORE checking, i.e. for each(hstore from ConfigLookUp Table, check that hstore key exists). TBD.
	    --IF NOT EXISTS (SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtablename AND columns ?& AKEYS(SetUpColumns)) THEN
	      --RAISE NOTICE '++++++++++ Provided HSTORE columns are lacking necessary pieces! +++++++++++';
	      --RETURN 1;
	    --END IF;
	    RETURN 0;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertCrateConfiguration( config_name     TEXT,
	  	      	 	 	  		   config_id       INT,
	     	      	 	  			   crate_default   HSTORE, 
							   slot_default      HSTORE, 
							   channel_default HSTORE, 
							   crate_mask   BIT(64),
							   slot_mask    BIT(64),
							   channel_mask BIT(64)
							   );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertSubConfiguration( config_name     TEXT,
	  	      	 	 			 config_id       INT,
	     	      	 	 			 crate_default   HSTORE, 
							 slot_default      HSTORE, 
							 channel_default HSTORE, 
							 crate_mask   BIT(64),
							 slot_mask    BIT(64),
							 channel_mask BIT(64)
							 );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertSubConfiguration( config_name     TEXT,
	     	      	 	 			   config_id       INT,
	     	      	 	 			   crate_default   HSTORE, 
							   slot_default    HSTORE, 
	 						   channel_default HSTORE,
							   crate_mask   BIT(64) DEFAULT '111111111111111'::BIT(64),
							   slot_mask    BIT(64) DEFAULT '1111111111111111111111111111111111111111111111111111111111111111',
	 						   channel_mask BIT(64) DEFAULT '0'::BIT(64)
							   ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  myrec RECORD;
	  BEGIN
	
	  IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	    RAISE EXCEPTION '++++++++++ Configuration % does not exist! +++++++++++', config_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID=%s LIMIT 1',config_name,config_id);
	  EXECUTE query INTO myrec;
	  IF NOT myrec.bool IS NULL THEN
	    RAISE EXCEPTION '++++++++++ Configuration % with ID % is already defined! +++++++++++', config_name, config_id;
	  END IF;
	
	--  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-999,-1,'''||slot_default||''','''||slot_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-1,-999,'''||channel_default||''','''||channel_mask||''')';
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendCrateConfiguration( config_name TEXT,
	     	      	 	 			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendSubConfiguration( config_name TEXT,
	     	      	 	 			 config_id   INT,
							 crate_id    INT,
							 slot_id     INT,
							 channel_id  INT,
							 Mask        BIT(64),
							 params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION AppendSubConfiguration( config_name TEXT,
	       	  	  	   			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  rec   RECORD;
	  BEGIN
	  
	    SELECT CheckNewCrateConfiguration(config_name, config_id, crate_id, slot_id, channel_id, params) AS VAL INTO rec;
	    IF rec.VAL = 1 THEN
	      RAISE EXCEPTION '+++++++++ Invalid subconfiguration! Aborting +++++++++';
	    RETURN 1;
	  END IF;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||','||crate_id||','''||slot_id||''','''||channel_id||''','''||params||''','''||Mask||''')';
	  RAISE INFO '%', query;
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateConfig( sub_conf_name TEXT,
	     	      	 			   sub_conf_id   INT,
						   crate_id      INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  conf_params.Crate := crate_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate = %s OR Crate = -999) AND SLOT = -1 AND Channel = -1 ORDER BY Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotConfig( sub_conf_name TEXT,
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT,
						  slot_id       INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  slot_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id);
	
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetChannelConfig( sub_conf_name TEXT,
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT,
						     channel_id    INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  channel_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;
	  IF NOT ARRAY[channel_id] <@ channel_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot,Channel) = (%,%,%) is not enabled! ++++++++++++',crate_id,slot_id,channel_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	  conf_params.Channel := channel_id;
	  conf_params.Params  := '';  
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Channel = -999 OR (Crate = %s AND Slot = %s AND Channel = %s)) ORDER BY Channel ASC, Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id,
			   channel_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	 sub_conf_id   INT,
						     	 crate_id      INT,
						     	 slot_id       INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  params HSTORE;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  channel_v INT[];
	  channel_id INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN NEXT conf_params;
	  ELSE
	
	    conf_params.Crate   := crate_id;
	    conf_params.Slot    := slot_id;
	    conf_params.Channel := -1;
	    conf_params.Params  := '';
	
	    query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	     sub_conf_name,
			     sub_conf_id,
			     crate_id,
			     slot_id);
	
	    FOR rec IN EXECUTE query LOOP
	      conf_params.Params := conf_params.Params || rec.Parameters;
	    END LOOP;
	
	    RETURN NEXT conf_params;
	
	    SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;  
	    FOREACH channel_id IN ARRAY channel_v LOOP
	
	      SELECT GetChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id, channel_id) INTO rec;
	      
	      conf_params := rec.getchannelconfig;
	      
	      RETURN NEXT conf_params;
	    END LOOP;
	  END IF;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	      sub_conf_id   INT,
						     	      crate_id      INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  slot_id   INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  --SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO conf_params;
	  SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO rec;
	  conf_params := rec.getcrateconfig;
	  RETURN NEXT conf_params;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  FOREACH slot_id IN ARRAY slot_v LOOP
	    FOR rec IN SELECT GetSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id) LOOP
	      conf_params := rec.GetSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 			     	      sub_conf_name  TEXT ) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  sub_conf_id INT;
	  crate_v INT[];
	  crate_id INT;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  SELECT SubConfigID( main_conf_name,sub_conf_name) INTO sub_conf_id;
	  SELECT ListEnabledCrates( main_conf_name, sub_conf_name ) INTO crate_v;
	  FOREACH crate_id IN ARRAY crate_v LOOP
	    FOR rec in SELECT GetCrateSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id) LOOP
	      conf_params := rec.GetCrateSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertMainConfiguration( subconfigparameters HSTORE,
	       	  	  	   			    subconfigmasks HSTORE,
	       	  	  	   			    confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
	    myrec2 RECORD;
	    myrec3 RECORD;
	    ColumnPair RECORD;
	    SubConfigCount INT;
	    -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    SubConfT INT;
	    --mainconfigexists INT;
	    localconfigexists INT;
	    BEGIN    
	
	    -- 1st CHECK: check if the provided Config ID already exsits in the MainConfigTable or not
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
		RETURN -1;
	    END IF;
	    -- now we know that the name doesn't exist or the user doesn't care.
	
	    -- 2nd CHECK: check if specified SubConfigType and SubConfigID are available or not
	    FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        -- Check if SubConfigType is valid or not
	        --        RAISE NOTICE 'key:%, value: %', ColumnPair.key, ColumnPair.value;
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
		    RETURN 1;
		END IF;
		-- Check if SubConfigID is valid or not
		query := format('SELECT TRUE FROM %s WHERE ConfigID=%s',ColumnPair.key,ColumnPair.value);
		EXECUTE query INTO myrec2;
		IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
		    RETURN 1;
		END IF;
		
	    END LOOP;
	    -- 3rd CHECK: subconfigmasks HSTORE keys has to be a subset of subconfigparameters HSTORE, and values must be BIGINT compatible type
	    IF NOT AKEYS(subconfigparameters) @> AKEYS(subconfigmasks) THEN
	      RAISE EXCEPTION '++++++++++++++ Mask contains configuration that is not in the list of subconfigurations! +++++++++++++';
	    END IF;
	
	    FOR ColumnPair IN SELECT (each(subconfigmasks)).*
	    LOOP
		SELECT textregexeq(ColumnPair.value,'^[0-1]+(\.[0-1]+)?$') AS VAL INTO myrec2;
		IF NOT myrec2.VAL THEN
		  RAISE EXCEPTION '++++++++++++ Config % Mask % is not a valid binary expression +++++++++++++',ColumnPair.key,ColumnPair.value;
		END IF;
	    END LOOP;
	
	    -- mainconfigexists:=1;  -- assuming it exists. Let's be proven otherwise.
	    --let's check if the configuration exists:
	    -- since we want to check the configuration sets, it's ok if we just choose the first subconfigtype and ID.
	    -- and then we loop over all of the subsets of MainconfigTable to see if they contain all of the other ones.
	
	    -- !!! Still missing. Find that the configuration we havefound does not have more rows than we need. !!!
	
	
	    SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;  -- only use the first.
	    --get subconfig type
	    ------------------------------ this repeats the functionality from later.
	
	    SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	    --looping over all mainconfigs that have the above parameters. 
	    for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	
	         -- Report
	--         RAISE NOTICE 'Checking against Main Config ID %', myrec3;
	
		 -- First check the # of sub-config types in this configuration. If not same as the # elements in subconfigparameters, continue.
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
	--	 SubConfigCount := SubConfigCount - ARRAY_LENGTH(AKEYS(subconfigparameters));
	--	 SELECT COUNT(TRUE) - SubConfigCount FROM 
	--	 IF SubConfigCount = 0
		 IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
		 END IF;
	
	         -- loop over all of the new, to be insterted config setting and check if the current configID has them all.
	         localconfigexists := 1;
		 for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	             IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
			  EXIT;   -- break out of loop. We already know, this is not the right config.
		     END IF;
	             END LOOP;
	         IF localconfigexists = 1    -- we've gone through all of the PMT settings and all exist.
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
		    RETURN -1;
		 END IF;
	     END LOOP;  -- end of myrec3 FOR loop over all of the subconfigs
	
	
	--     IF mainconfigexists = 1
	--       THEN RAISE EXCEPTION '+++++++++++++ Config already exists in MainConfigTable, with ID: %! +++++++++++++',-1;
	--     END IF;
	   ----------- To be improved
	   --------------------------------- Find the last entry
	    SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
	    IF newconfig IS NULL
	      THEN  newconfig := 0;
	    ELSE
	       newconfig := newconfig + 1;
	    END IF;
	    
	    RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
	   
	    -- Reaching this point means input values are valid. Let's insert.
	   FOR myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
	    SELECT subconfigmasks->myrec1.key AS VAL INTO myrec2;
	    IF myrec2.VAL IS NULL THEN
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      '111111111111'::BIT(64),
					      confname);
	    ELSE
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      CAST(myrec2.VAL AS BIT(64)),
					      confname);
	    END IF;
	
	    END LOOP;
	
	   RETURN newconfig;
	   END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
	    conftype ConfigLookUp.SubConfigType%TYPE;
	    mainconfrow mainconfigtable%ROWTYPE; --.subconfigparentid%TYPE;
	    subconfigconfigrec subconfigreturntype;
	    query   text;
	    testquery text;
	    mainconfquery text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', tablename;
	
	       --'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || subconfigid ;
	      testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
	      RAISE INFO 'testquery % ', testquery;
	      EXECUTE testquery INTO conftype;
	
	      RAISE INFO 'SELECTED % ', conftype;
	
	      mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || ' AND configid='||mainconfigid;  
	
	      RAISE INFO ' % ', mainconfquery ;
	   
	      EXECUTE mainconfquery INTO mainconfrow;
	
	      RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
	  
	  ---- SELECT   
	      query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
	
	      for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;  --inserting the name for faster lookup later
	      subconfigconfigrec.ConfigType:=conftype;   --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	      end loop;
	      return;
	
	     -- RAISE INFO ' % ', query ;
	
	     -- EXECUTE query INTO myrec; 
	     -- IF myrec.parameterx IS NULL  THEN
		--  RAISE EXCEPTION 'Configuration % not found', subconfigid;
	     -- END IF;
	
	--- SELECT PARENT, THEN SELECT INTO RECORD the STANDARD CONFIG WHERE MODULEID
	--- DO we want to get the ultimate Parent?
	--- This means that the flattened parent needs to have a -1? 
	--- need to keep a list of previous parents when looping
	
	
	
	--      query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	-- 
	    --   RAISE INFO 'result? % ', myrec ;
	-- 
	--       EXECUTE query INTO myrec; 
	-- 	IF myrec.configid IS NULL  THEN
	-- 	  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
	-- 	END IF;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	       -- RETURN myrec;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist at character 116
STATEMENT:  CREATE TABLE  ConfigLookUp  (
	   SubConfigType  INT NOT NULL,
	   SubConfigName VARCHAR  NOT NULL,
	   SetupColumns  HSTORE,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	  PRIMARY KEY ( SubConfigType )
	);
ERROR:  type "hstore" does not exist
STATEMENT:  CREATE TYPE UnitConfig AS ( Crate INT, Slot INT, Channel INT, Params HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  CREATE  TYPE subconfigreturntype as 
	(  ConfigID  INTEGER ,
	   Crate  SMALLINT  ,
	   Channel  SMALLINT ,
	   Parameters  HSTORE , 
	   userID  VARCHAR,
	   TimeStamp  TIMESTAMP,
	   ConfigName varchar,
	   ConfigType INTEGER);
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('TriggerConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('PMTConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('TPCConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('CalibrationConfig','');
ERROR:  type "hstore" does not exist at character 116
STATEMENT:  CREATE TABLE  ConfigLookUp  (
	   SubConfigType  INT NOT NULL,
	   SubConfigName VARCHAR  NOT NULL,
	   SetupColumns  HSTORE,
	   userID  VARCHAR NULL DEFAULT NULL,
	   TimeStamp  TIMESTAMP NULL DEFAULT NULL,
	  PRIMARY KEY ( SubConfigType )
	);
ERROR:  type "hstore" does not exist
STATEMENT:  CREATE TYPE UnitConfig AS ( Crate INT, Slot INT, Channel INT, Params HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  CREATE  TYPE subconfigreturntype as 
	(  ConfigID  INTEGER ,
	   Crate  SMALLINT  ,
	   Channel  SMALLINT ,
	   Parameters  HSTORE , 
	   userID  VARCHAR,
	   TimeStamp  TIMESTAMP,
	   ConfigName varchar,
	   ConfigType INTEGER);
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('TriggerConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('PMTConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('TPCConfig','');
ERROR:  function createconfigurationtype(unknown, unknown) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT CreateConfigurationType('CalibrationConfig','');
ERROR:  relation "configlookup" does not exist at character 105
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	   SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = SCfgName LIMIT 1
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigParameters(SCfgName TEXT) RETURNS SETOF TEXT AS $$
	   SELECT skeys(setupcolumns) FROM configlookup WHERE subconfigname = SCfgName
	$$ LANGUAGE SQL;
ERROR:  relation "configlookup" does not exist at character 128
STATEMENT:  CREATE OR REPLACE FUNCTION ListSubConfigNameAndID() RETURNS SETOF RECORD AS $$
	       SELECT SubConfigName, SubConfigType FROM ConfigLookUp ORDER BY SubConfigType
	$$ LANGUAGE SQL;
ERROR:  invalid type name "ConfigLookUp.SubConfigName%TYPE" at character 127
STATEMENT:  CREATE OR REPLACE FUNCTION mainconfigcheck() RETURNS trigger AS $mainconfigcheck$
	    DECLARE
	    myrec RECORD;
	    tablename ConfigLookUp.SubConfigName%TYPE;
	    query   text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', NEW.subconfigtype;
	
	      SELECT  configname FROM configtypes WHERE configtypes.configtype=NEW.subconfigtype INTO tablename;
	
	      RAISE INFO 'SELECTED % ', tablename;
	
	     
	   
	  --  
	    query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigid ;
	
	    RAISE INFO ' % ', query ;
	
	    EXECUTE query INTO myrec; 
	      IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Configuration % not found', NEW.subconfigid;
	      END IF;
	
	     query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	
	      RAISE INFO ' % ', query ;
	
	      EXECUTE query INTO myrec; 
		IF myrec.configid IS NULL  THEN
		  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
		END IF;
	--       EXECUTE 'SELECT configid FROM '
	-- 	|| tablename 
	-- 	|| ' WHERE '
	-- 	|| tablename
	-- 	|| '.configid ='
	-- 	|| substring(NEW.subconfigid,1,1) 
	--       INTO myrec;
	      --SELECT INTO myrec * FROM mainconfigtable WHERE mainconfigtable.configid=NEW.configid;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	        RETURN NEW;
	    END;
	$mainconfigcheck$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION ReturnConfigurationByNumber(requestedConfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    mainconfrec RECORD;
	    configlookuprec RECORD;
	    subconfigconfigrec subconfigreturntype;
	    subconfigquery  text ;
	    BEGIN
	       
		--select subconfigTypes and their numbers from the MainConfigTable
	
	    FOR mainconfrec IN SELECT SubConfigType,SubConfigID,SubConfigParentID,SubConfigOnMask FROM MainConfigTable 
	    WHERE Configid=requestedConfigid LOOP
	
	    RAISE INFO ' subconfig Type: %, ID: %, SubConfigParentID: %,  ',mainconfrec.SubConfigType,mainconfrec.SubConfigID,mainconfrec.SubConfigParentID;
	 
	    -- querying the lookup table to find out, what it is that we're picking up from the subconfig table
	    SELECT INTO configlookuprec * FROM ConfigLookUp WHERE ConfigLookup.SubConfigType=mainconfrec.SubConfigType;
	
	    RAISE INFO ' config name: % and parameters: % ',configlookuprec.SubConfigName,configlookuprec.SetupColumns;
	
	    -- Create JOIN of Main config table and subtable and return that
	    subconfigquery := 'SELECT *  FROM ' || configlookuprec.SubConfigName || ' WHERE ' || configlookuprec.SubConfigName || 
		  '.ConfigID = '||mainconfrec.SubConfigID;
	
	    RAISE INFO 'sub conf query: %',subconfigquery;
	
	 
	    for subconfigconfigrec in EXECUTE subconfigquery loop
	       subconfigconfigrec.ConfigName:=configlookuprec.SubConfigName;  --inserting the name for faster lookup later
	       subconfigconfigrec.ConfigType:=mainconfrec.SubConfigType;      --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	    end loop;
	
	  END LOOP;
	
	  RETURN;
	   
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GETQUERY2(configtabletype text,insubconfid INT,inmodule INT,columns HSTORE) RETURNS TEXT AS $$
	DECLARE
	  query text;
	  BEGIN
	  
	  query := format('SELECT * FROM %s WHERE ConfigID=%s AND ModuleID=%s',configtabletype,insubconfid,inmodule);
	--  return query;
	--  SELECT query;
	  EXECUTE query;
	--  RETURN query;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewCrateConfiguration( config_name TEXT,
	     	      	 			            config_id   INT,
							    crate_id    INT,
							    slot_id     INT,
							    channel_id  INT,
							    params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS CheckNewSubConfiguration( config_name TEXT,
	     	      	 			          config_id   INT,
							  crate_id    INT,
							  slot_id     INT,
							  channel_id  INT,
							  params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION CheckNewSubConfiguration( config_name TEXT,
	       	  	  	   			     config_id   INT,
							     crate_id    INT,
							     slot_id     INT,
							     channel_id  INT,
							     params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	    myrec RECORD;
	    newconfig INT;
	    query text;  
	    ColumnPair RECORD;
	  BEGIN
	
	 -- Check 0) Possible combination of crate_id, slot_id, and channel_id
	    IF crate_id < 0 AND NOT (crate_id = -1 OR crate_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Crate ID: % +++++++++++', crate_id;
	      RETURN 1;
	
	    ELSIF slot_id < 0 AND NOT (slot_id = -1 OR slot_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Slot ID: % +++++++++++', slot_id;
	      RETURN 1;
	
	    ELSIF channel_id < 0 AND NOT (channel_id = -1 OR channel_id = -999) THEN
	      RAISE NOTICE '++++++++++ Invalid Channel ID: % +++++++++++', channel_id;
	      RETURN 1;
	
	    ELSIF ((crate_id + channel_id + slot_id) < -1001) THEN
	      RAISE NOTICE '++++++++++ Duplicate -999 values among (crate,slot,channel)=(%,%,%) ++++++++++++', crate_id, slot_id, channel_id;
	      RETURN 1;
	
	    ELSIF channel_id = -999 AND (crate_id = -1  AND slot_id >= 0) THEN
	      RAISE NOTICE '++++++++++ Crate ID must be 0 or positive integer for a specific slot default channel! ++++++++++';
	      RETURN 1;
	
	    ELSIF slot_id = -999 AND  channel_id != -1 THEN
	      RAISE NOTICE '++++++++++ Channel ID must be -1 if Slot ID is -999! +++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -999 AND (slot_id >=0 OR channel_id >=0 ) THEN
	      RAISE NOTICE '++++++++++ Slot and Channel ID must be -1 for default Crate config (ID=-999) ++++++++++';
	      RETURN 1;
	
	    ELSIF crate_id = -1 AND (slot_id >= 0 OR channel_id >= 0) THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (-1, %, %) not allowed! +++++++++++',slot_id,channel_id;
	      RETURN 1;
	
	    ELSIF crate_id >= 0 AND slot_id = -1 AND channel_id >= 0 THEN
	      RAISE NOTICE '++++++++++ (Crate,Slot,Channel) = (%, -1, %) not allowed! +++++++++++',crate_id,channel_id;
	      RETURN 1;
	
	    END IF;
	
	 -- Check 1) find if this configuration type exists. If not, don't do anything
	    IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	      RAISE NOTICE '++++++++++ Configuration % is not defined yet! +++++++++++', config_name;
	      RETURN 1;
	    END IF;
	
	 -- Check 2) find if this config ID is already defined or not. If not, don't do anything
	    query := format('SELECT 1 AS VAL FROM %s WHERE ConfigID=%s LIMIT 1;',config_name,config_id);
	    EXECUTE query INTO myrec;
	    IF myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ Configuration % with ID % is not defined yet! +++++++++++', config_name, config_id;
	      RETURN 1;
	    END IF;
	
	 -- Check 3) find if a config like this exists. If does, don't do anything
	    query := format('SELECT TRUE AS VAL FROM %s WHERE ConfigID=%s AND Crate=%s AND Slot=%s AND Channel=%s',config_name,config_id, crate_id, slot_id, channel_id);
	    EXECUTE query INTO myrec;
	    IF NOT myrec.VAL IS NULL THEN
	      RAISE NOTICE '++++++++++ (ConfigID,Crate,Slot,Channel) = (%,%,%,%) already exists! ++++++++++', config_id, crate_id, slot_id, channel_id;
	      RETURN 1;
	    END IF;
	
	    -- INSERT HSTORE checking, i.e. for each(hstore from ConfigLookUp Table, check that hstore key exists). TBD.
	    --IF NOT EXISTS (SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtablename AND columns ?& AKEYS(SetUpColumns)) THEN
	      --RAISE NOTICE '++++++++++ Provided HSTORE columns are lacking necessary pieces! +++++++++++';
	      --RETURN 1;
	    --END IF;
	    RETURN 0;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertCrateConfiguration( config_name     TEXT,
	  	      	 	 	  		   config_id       INT,
	     	      	 	  			   crate_default   HSTORE, 
							   slot_default      HSTORE, 
							   channel_default HSTORE, 
							   crate_mask   BIT(64),
							   slot_mask    BIT(64),
							   channel_mask BIT(64)
							   );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  InsertSubConfiguration( config_name     TEXT,
	  	      	 	 			 config_id       INT,
	     	      	 	 			 crate_default   HSTORE, 
							 slot_default      HSTORE, 
							 channel_default HSTORE, 
							 crate_mask   BIT(64),
							 slot_mask    BIT(64),
							 channel_mask BIT(64)
							 );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertSubConfiguration( config_name     TEXT,
	     	      	 	 			   config_id       INT,
	     	      	 	 			   crate_default   HSTORE, 
							   slot_default    HSTORE, 
	 						   channel_default HSTORE,
							   crate_mask   BIT(64) DEFAULT '111111111111111'::BIT(64),
							   slot_mask    BIT(64) DEFAULT '1111111111111111111111111111111111111111111111111111111111111111',
	 						   channel_mask BIT(64) DEFAULT '0'::BIT(64)
							   ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  myrec RECORD;
	  BEGIN
	
	  IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = config_name) THEN
	    RAISE EXCEPTION '++++++++++ Configuration % does not exist! +++++++++++', config_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID=%s LIMIT 1',config_name,config_id);
	  EXECUTE query INTO myrec;
	  IF NOT myrec.bool IS NULL THEN
	    RAISE EXCEPTION '++++++++++ Configuration % with ID % is already defined! +++++++++++', config_name, config_id;
	  END IF;
	
	--  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-999,-1,-1,'''||crate_default||''','''||crate_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-999,-1,'''||slot_default||''','''||slot_mask||''')';
	  execute query;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||',-1,-1,-999,'''||channel_default||''','''||channel_mask||''')';
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendCrateConfiguration( config_name TEXT,
	     	      	 	 			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE );
ERROR:  type "hstore" does not exist
STATEMENT:  DROP FUNCTION IF EXISTS  AppendSubConfiguration( config_name TEXT,
	     	      	 	 			 config_id   INT,
							 crate_id    INT,
							 slot_id     INT,
							 channel_id  INT,
							 Mask        BIT(64),
							 params      HSTORE );
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION AppendSubConfiguration( config_name TEXT,
	       	  	  	   			   config_id   INT,
							   crate_id    INT,
							   slot_id     INT,
							   channel_id  INT,
							   Mask        BIT(64),
							   params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	  query text;
	  rec   RECORD;
	  BEGIN
	  
	    SELECT CheckNewCrateConfiguration(config_name, config_id, crate_id, slot_id, channel_id, params) AS VAL INTO rec;
	    IF rec.VAL = 1 THEN
	      RAISE EXCEPTION '+++++++++ Invalid subconfiguration! Aborting +++++++++';
	    RETURN 1;
	  END IF;
	
	  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||','||crate_id||','''||slot_id||''','''||channel_id||''','''||params||''','''||Mask||''')';
	  RAISE INFO '%', query;
	  execute query;
	
	  RETURN 0;
	  END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateConfig( sub_conf_name TEXT,
	     	      	 			   sub_conf_id   INT,
						   crate_id      INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  conf_params.Crate := crate_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate = %s OR Crate = -999) AND SLOT = -1 AND Channel = -1 ORDER BY Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotConfig( sub_conf_name TEXT,
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT,
						  slot_id       INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  slot_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id);
	
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetChannelConfig( sub_conf_name TEXT,
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT,
						     channel_id    INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  channel_v INT[];
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;
	  IF NOT ARRAY[channel_id] <@ channel_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot,Channel) = (%,%,%) is not enabled! ++++++++++++',crate_id,slot_id,channel_id;
	    RETURN conf_params;
	  END IF;
	
	  conf_params.Crate   := crate_id;
	  conf_params.Slot    := slot_id;
	  conf_params.Channel := channel_id;
	  conf_params.Params  := '';  
	
	  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Channel = -999 OR (Crate = %s AND Slot = %s AND Channel = %s)) ORDER BY Channel ASC, Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id,
			   channel_id);
	  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
	  END LOOP;
	
	  --RAISE INFO '%',conf_params;
	  RETURN conf_params;
	
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	 sub_conf_id   INT,
						     	 crate_id      INT,
						     	 slot_id       INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  params HSTORE;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  channel_v INT[];
	  channel_id INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
	    RETURN NEXT conf_params;
	  ELSE
	
	    conf_params.Crate   := crate_id;
	    conf_params.Slot    := slot_id;
	    conf_params.Channel := -1;
	    conf_params.Params  := '';
	
	    query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	     sub_conf_name,
			     sub_conf_id,
			     crate_id,
			     slot_id);
	
	    FOR rec IN EXECUTE query LOOP
	      conf_params.Params := conf_params.Params || rec.Parameters;
	    END LOOP;
	
	    RETURN NEXT conf_params;
	
	    SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;  
	    FOREACH channel_id IN ARRAY channel_v LOOP
	
	      SELECT GetChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id, channel_id) INTO rec;
	      
	      conf_params := rec.getchannelconfig;
	      
	      RETURN NEXT conf_params;
	    END LOOP;
	  END IF;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	      sub_conf_id   INT,
						     	      crate_id      INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  exist  BOOLEAN;
	  conf_params UnitConfig;
	  rec    RECORD;
	  rec_set RECORD;
	  slot_v    INT[];
	  slot_id   INT;
	BEGIN
	
	  conf_params.Crate   := -1;
	  conf_params.Slot    := -1;
	  conf_params.Channel := -1;
	  conf_params.Params  := '';
	
	  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
	  END IF;
	  
	  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
	  EXECUTE query INTO exist;
	  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
	  END IF;
	
	  --SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO conf_params;
	  SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO rec;
	  conf_params := rec.getcrateconfig;
	  RETURN NEXT conf_params;
	
	  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
	  FOREACH slot_id IN ARRAY slot_v LOOP
	    FOR rec IN SELECT GetSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id) LOOP
	      conf_params := rec.GetSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 			     	      sub_conf_name  TEXT ) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
	  sub_conf_id INT;
	  crate_v INT[];
	  crate_id INT;
	  conf_params UnitConfig;
	  rec    RECORD;
	BEGIN
	
	  SELECT SubConfigID( main_conf_name,sub_conf_name) INTO sub_conf_id;
	  SELECT ListEnabledCrates( main_conf_name, sub_conf_name ) INTO crate_v;
	  FOREACH crate_id IN ARRAY crate_v LOOP
	    FOR rec in SELECT GetCrateSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id) LOOP
	      conf_params := rec.GetCrateSlotChannelConfig;
	      RETURN NEXT conf_params;
	    END LOOP;
	  END LOOP;
	END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type hstore does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION InsertMainConfiguration( subconfigparameters HSTORE,
	       	  	  	   			    subconfigmasks HSTORE,
	       	  	  	   			    confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
	    myrec2 RECORD;
	    myrec3 RECORD;
	    ColumnPair RECORD;
	    SubConfigCount INT;
	    -- maskconfig INT;
	    newconfig INT;
	    query text;  
	    SubConfT INT;
	    --mainconfigexists INT;
	    localconfigexists INT;
	    BEGIN    
	
	    -- 1st CHECK: check if the provided Config ID already exsits in the MainConfigTable or not
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
		RETURN -1;
	    END IF;
	    -- now we know that the name doesn't exist or the user doesn't care.
	
	    -- 2nd CHECK: check if specified SubConfigType and SubConfigID are available or not
	    FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        -- Check if SubConfigType is valid or not
	        --        RAISE NOTICE 'key:%, value: %', ColumnPair.key, ColumnPair.value;
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
		    RETURN 1;
		END IF;
		-- Check if SubConfigID is valid or not
		query := format('SELECT TRUE FROM %s WHERE ConfigID=%s',ColumnPair.key,ColumnPair.value);
		EXECUTE query INTO myrec2;
		IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
		    RETURN 1;
		END IF;
		
	    END LOOP;
	    -- 3rd CHECK: subconfigmasks HSTORE keys has to be a subset of subconfigparameters HSTORE, and values must be BIGINT compatible type
	    IF NOT AKEYS(subconfigparameters) @> AKEYS(subconfigmasks) THEN
	      RAISE EXCEPTION '++++++++++++++ Mask contains configuration that is not in the list of subconfigurations! +++++++++++++';
	    END IF;
	
	    FOR ColumnPair IN SELECT (each(subconfigmasks)).*
	    LOOP
		SELECT textregexeq(ColumnPair.value,'^[0-1]+(\.[0-1]+)?$') AS VAL INTO myrec2;
		IF NOT myrec2.VAL THEN
		  RAISE EXCEPTION '++++++++++++ Config % Mask % is not a valid binary expression +++++++++++++',ColumnPair.key,ColumnPair.value;
		END IF;
	    END LOOP;
	
	    -- mainconfigexists:=1;  -- assuming it exists. Let's be proven otherwise.
	    --let's check if the configuration exists:
	    -- since we want to check the configuration sets, it's ok if we just choose the first subconfigtype and ID.
	    -- and then we loop over all of the subsets of MainconfigTable to see if they contain all of the other ones.
	
	    -- !!! Still missing. Find that the configuration we havefound does not have more rows than we need. !!!
	
	
	    SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;  -- only use the first.
	    --get subconfig type
	    ------------------------------ this repeats the functionality from later.
	
	    SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	    --looping over all mainconfigs that have the above parameters. 
	    for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	
	         -- Report
	--         RAISE NOTICE 'Checking against Main Config ID %', myrec3;
	
		 -- First check the # of sub-config types in this configuration. If not same as the # elements in subconfigparameters, continue.
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
	--	 SubConfigCount := SubConfigCount - ARRAY_LENGTH(AKEYS(subconfigparameters));
	--	 SELECT COUNT(TRUE) - SubConfigCount FROM 
	--	 IF SubConfigCount = 0
		 IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
		 END IF;
	
	         -- loop over all of the new, to be insterted config setting and check if the current configID has them all.
	         localconfigexists := 1;
		 for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
	             IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
			  EXIT;   -- break out of loop. We already know, this is not the right config.
		     END IF;
	             END LOOP;
	         IF localconfigexists = 1    -- we've gone through all of the PMT settings and all exist.
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
		    RETURN -1;
		 END IF;
	     END LOOP;  -- end of myrec3 FOR loop over all of the subconfigs
	
	
	--     IF mainconfigexists = 1
	--       THEN RAISE EXCEPTION '+++++++++++++ Config already exists in MainConfigTable, with ID: %! +++++++++++++',-1;
	--     END IF;
	   ----------- To be improved
	   --------------------------------- Find the last entry
	    SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
	    IF newconfig IS NULL
	      THEN  newconfig := 0;
	    ELSE
	       newconfig := newconfig + 1;
	    END IF;
	    
	    RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
	   
	    -- Reaching this point means input values are valid. Let's insert.
	   FOR myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
	    SELECT subconfigmasks->myrec1.key AS VAL INTO myrec2;
	    IF myrec2.VAL IS NULL THEN
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      '111111111111'::BIT(64),
					      confname);
	    ELSE
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      CAST(myrec2.VAL AS BIT(64)),
					      confname);
	    END IF;
	
	    END LOOP;
	
	   RETURN newconfig;
	   END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "subconfigreturntype" does not exist
STATEMENT:  CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
	    conftype ConfigLookUp.SubConfigType%TYPE;
	    mainconfrow mainconfigtable%ROWTYPE; --.subconfigparentid%TYPE;
	    subconfigconfigrec subconfigreturntype;
	    query   text;
	    testquery text;
	    mainconfquery text;
	    BEGIN
	        -- Check that empname and salary are given
	      RAISE INFO 'subconfigid % ', tablename;
	
	       --'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || subconfigid ;
	      testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
	      RAISE INFO 'testquery % ', testquery;
	      EXECUTE testquery INTO conftype;
	
	      RAISE INFO 'SELECTED % ', conftype;
	
	      mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || ' AND configid='||mainconfigid;  
	
	      RAISE INFO ' % ', mainconfquery ;
	   
	      EXECUTE mainconfquery INTO mainconfrow;
	
	      RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
	  
	  ---- SELECT   
	      query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
	
	      for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;  --inserting the name for faster lookup later
	      subconfigconfigrec.ConfigType:=conftype;   --inserting type for faster lookup
	
	      return next subconfigconfigrec;
	      end loop;
	      return;
	
	     -- RAISE INFO ' % ', query ;
	
	     -- EXECUTE query INTO myrec; 
	     -- IF myrec.parameterx IS NULL  THEN
		--  RAISE EXCEPTION 'Configuration % not found', subconfigid;
	     -- END IF;
	
	--- SELECT PARENT, THEN SELECT INTO RECORD the STANDARD CONFIG WHERE MODULEID
	--- DO we want to get the ultimate Parent?
	--- This means that the flattened parent needs to have a -1? 
	--- need to keep a list of previous parents when looping
	
	
	
	--      query := 'SELECT configid FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || NEW.subconfigparentid ;
	-- 
	    --   RAISE INFO 'result? % ', myrec ;
	-- 
	--       EXECUTE query INTO myrec; 
	-- 	IF myrec.configid IS NULL  THEN
	-- 	  RAISE EXCEPTION 'Parent Configuration % not found', NEW.subconfigparentid;
	-- 	END IF;
	       
	
	
	       
	       -- Remember who changed the payroll when
	       -- NEW.timestop := 'now';
	       -- NEW.userid := current_user;
	       -- RETURN myrec;
	    END;
	$$ LANGUAGE plpgsql VOLATILE STRICT;
ERROR:  type "unitconfig" already exists
STATEMENT:  CREATE TYPE UnitConfig AS ( Crate INT, Slot INT, Channel INT, Params HSTORE );
ERROR:  type "unitconfig" already exists
STATEMENT:  CREATE TYPE UnitConfig AS ( Crate INT, Slot INT, Channel INT, Params HSTORE );
ERROR:  syntax error at or near "RETURNS" at character 262
STATEMENT:  DROP FUNCTION IF EXISTS  FillSubConfiguration( config_name TEXT,
	       	  	  	   		       config_id   INT,
						       crate_id    INT,
						       slot_id     INT,
						       channel_id  INT,
						       Mask        BIT(64),
						       params      HSTORE ) RETURNS INT AS $$
	
	CREATE OR REPLACE FUNCTION FillSubConfiguration( config_name TEXT,
	       	  	  	   			 config_id   INT,
							 crate_id    INT,
							 slot_id     INT,
							 channel_id  INT,
							 Mask        BIT(64),
							 params      HSTORE ) RETURNS INT AS $$
	  DECLARE
	  query text;
ERROR:  syntax error at or near "rec" at character 1
STATEMENT:  rec   RECORD;
ERROR:  syntax error at or near "SELECT" at character 14
STATEMENT:  BEGIN
	  
	    SELECT CheckNewCrateConfiguration(config_name, config_id, crate_id, slot_id, channel_id, params) AS VAL INTO rec;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF rec.VAL = 1 THEN
	      RAISE EXCEPTION '+++++++++ Invalid subconfiguration! Aborting +++++++++';
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 1;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := 'INSERT INTO '||config_name||'(ConfigID,Crate,Slot,Channel,Parameters,Mask) VALUES('||config_id||','||crate_id||','''||slot_id||''','''||channel_id||''','''||params||''','''||Mask||''')';
ERROR:  syntax error at or near "RAISE" at character 1
STATEMENT:  RAISE INFO '%', query;
ERROR:  prepared statement "query" does not exist
STATEMENT:  execute query;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 0;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	CREATE OR REPLACE FUNCTION MaxSubConfigID(configtablename TEXT) RETURNS INT AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	CREATE OR REPLACE FUNCTION MaxSubConfigID(configtablename TEXT) RETURNS INT AS $$
	DECLARE
	   myrec RECORD;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query TEXT;
ERROR:  syntax error at or near "IF" at character 14
STATEMENT:  BEGIN
	   
	   IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = configtablename )    
	     THEN RAISE EXCEPTION '++++++++++ Configuration % is not defined yet! +++++++++++', configtablename;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT ConfigID FROM %s ORDER BY ConfigID DESC LIMIT 1;',configtablename);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO myrec;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF myrec.ConfigID IS NULL
	       THEN RETURN -1;
ERROR:  syntax error at or near "ELSE" at character 1
STATEMENT:  ELSE 
	       RETURN myrec.ConfigID;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS MaskToArray( Mask BIT(64) );
	CREATE OR REPLACE FUNCTION MaskToArray( Mask BIT(64) ) RETURNS INT[] AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS MaskToArray( Mask BIT(64) );
	CREATE OR REPLACE FUNCTION MaskToArray( Mask BIT(64) ) RETURNS INT[] AS $$
	DECLARE
	   index      INT;
ERROR:  syntax error at or near "enabled_id" at character 1
STATEMENT:  enabled_id INT[];
ERROR:  syntax error at or near "local_mask" at character 1
STATEMENT:  local_mask BIGINT;
ERROR:  syntax error at or near "FOR" at character 14
STATEMENT:  BEGIN
	   
	   FOR i IN 0..63 LOOP
	     IF ((Mask<<i)::BIT(1) & 1::BIT(1)) = '1'::BIT(1) THEN
	       enabled_id = enabled_id || i;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN enabled_id;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS SubConfigType( sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION SubConfigType( sub_conf_name TEXT ) RETURNS INT AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS SubConfigType( sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION SubConfigType( sub_conf_name TEXT ) RETURNS INT AS $$
	DECLARE
	  sub_conf_type INT;
ERROR:  syntax error at or near "SELECT" at character 9
STATEMENT:  BEGIN
	  SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO sub_conf_type;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF sub_conf_type IS NULL THEN
	    RAISE EXCEPTION '++++++++++++ Config % not found! +++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN sub_conf_type;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS SubConfigID( main_conf_name TEXT,
	     	      	 		     sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION SubConfigID( main_conf_name TEXT,
	       	  	  	   		sub_conf_name TEXT ) RETURNS INT AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS SubConfigID( main_conf_name TEXT,
	     	      	 		     sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION SubConfigID( main_conf_name TEXT,
	       	  	  	   		sub_conf_name TEXT ) RETURNS INT AS $$
	DECLARE
	  sub_conf_type INT;
ERROR:  syntax error at or near "sub_conf_id" at character 1
STATEMENT:  sub_conf_id INT;
ERROR:  syntax error at or near "SELECT" at character 12
STATEMENT:  BEGIN
	  
	  SELECT SubConfigType(sub_conf_name) INTO sub_conf_type;
ERROR:  syntax error at or near "INTO" at character 109
STATEMENT:  SELECT SubConfigID FROM MainConfigTable WHERE ConfigName = main_conf_name AND SubConfigType = sub_conf_type INTO sub_conf_id;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF sub_conf_id IS NULL THEN
	    RAISE EXCEPTION '++++++++++++ Main Config = %, Sub-Config = % not found in MainConfigTable! +++++++++++++++',main_conf_name,sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN sub_conf_id;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS ListEnabledCrates( main_conf_name TEXT,
	     	      	 			   sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION ListEnabledCrates( main_conf_name TEXT,
	     	      	 			      sub_conf_name TEXT ) RETURNS INT[] AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS ListEnabledCrates( main_conf_name TEXT,
	     	      	 			   sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION ListEnabledCrates( main_conf_name TEXT,
	     	      	 			      sub_conf_name TEXT ) RETURNS INT[] AS $$
	DECLARE
	  rec        RECORD;
ERROR:  syntax error at or near "sub_conf_type" at character 1
STATEMENT:  sub_conf_type INT;
ERROR:  syntax error at or near "crate_mask" at character 1
STATEMENT:  crate_mask BIT(64);
ERROR:  syntax error at or near "crate_v" at character 1
STATEMENT:  crate_v    INT[];
ERROR:  syntax error at or near "SELECT" at character 12
STATEMENT:  BEGIN
	  
	  SELECT SubConfigType(sub_conf_name) INTO sub_conf_type;
ERROR:  syntax error at or near "INTO" at character 111
STATEMENT:  SELECT SubConfigMask FROM MainConfigTable WHERE ConfigName = main_conf_name AND SubConfigType = sub_conf_type INTO crate_mask;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT FOUND THEN
	    RAISE EXCEPTION '+++++++++++ (Config,SubConfig) = (%,%) not found in MainConfigTable ++++++++++++',main_conf_name,sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "crate_mask" does not exist at character 20
STATEMENT:  SELECT MaskToArray(crate_mask) INTO crate_v;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN crate_v;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	DROP FUNCTION IF EXISTS ListEnabledSlots( sub_conf_name TEXT, 
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT );
	
	CREATE OR REPLACE FUNCTION ListEnabledSlots( sub_conf_name TEXT, 
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT ) RETURNS INT[] AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	DROP FUNCTION IF EXISTS ListEnabledSlots( sub_conf_name TEXT, 
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT );
	
	CREATE OR REPLACE FUNCTION ListEnabledSlots( sub_conf_name TEXT, 
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT ) RETURNS INT[] AS $$
	DECLARE
	  exist BOOLEAN;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query TEXT;
ERROR:  syntax error at or near "slot_mask" at character 1
STATEMENT:  slot_mask BIT(64);
ERROR:  syntax error at or near "slot_v" at character 1
STATEMENT:  slot_v INT[];
ERROR:  syntax error at or near "IF" at character 9
STATEMENT:  BEGIN
	  IF crate_id < 0 THEN
	    RAISE EXCEPTION '+++++++++++ Query Crate ID (%) must be positive! ++++++++++++',crate_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "INTO" at character 67
STATEMENT:  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++ No Sub-Config named as % ++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s LIMIT 1',sub_conf_name,sub_conf_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++ ConfigID % not viable! +++++++++++++',sub_conf_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format( 'SELECT Mask FROM %s WHERE ConfigID = %s AND (Crate = %s OR Crate = -999) AND Slot = -1 AND Channel = -1 ORDER BY Crate DESC LIMIT 1;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO slot_mask;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF slot_mask IS NULL THEN
	    RAISE EXCEPTION '+++++++++++ Did not find mask for crate % (LOGIC ERROR ... default must exist!) ++++++++++++',crate_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "slot_mask" does not exist at character 20
STATEMENT:  SELECT MaskToArray(slot_mask) INTO slot_v;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN slot_v;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	-------------------------------------------------------------------------
	DROP FUNCTION IF EXISTS ListEnabledChannels( sub_conf_name TEXT, 
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT );
	
	CREATE OR REPLACE FUNCTION ListEnabledChannels( sub_conf_name TEXT, 
	     	      	 			     	sub_conf_id   INT,
						     	crate_id      INT,
							slot_id       INT ) RETURNS INT[] AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	-------------------------------------------------------------------------
	DROP FUNCTION IF EXISTS ListEnabledChannels( sub_conf_name TEXT, 
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT );
	
	CREATE OR REPLACE FUNCTION ListEnabledChannels( sub_conf_name TEXT, 
	     	      	 			     	sub_conf_id   INT,
						     	crate_id      INT,
							slot_id       INT ) RETURNS INT[] AS $$
	DECLARE
	  exist BOOLEAN;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query TEXT;
ERROR:  syntax error at or near "channel_mask" at character 1
STATEMENT:  channel_mask BIT(64);
ERROR:  syntax error at or near "channel_v" at character 1
STATEMENT:  channel_v INT[];
ERROR:  syntax error at or near "IF" at character 9
STATEMENT:  BEGIN
	  IF crate_id < 0 OR slot_id < 0 THEN
	    RAISE EXCEPTION '+++++++++++ Query Crate ID (%) and Slot ID (%) must be positive! ++++++++++++',crate_id,slot_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "INTO" at character 67
STATEMENT:  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++ No Sub-Config named as % ++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s LIMIT 1',sub_conf_name,sub_conf_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++ ConfigID % not viable! +++++++++++++',sub_conf_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format( 'SELECT Mask FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s) ) AND Channel = -1 ORDER BY Slot DESC, Crate DESC LIMIT 1;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO channel_mask;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF channel_mask IS NULL THEN
	    RAISE EXCEPTION '+++++++++++ Did not find mask for (Crate,Slot) (%,%) (LOGIC ERROR ... default must exist!) ++++++++++++',crate_id,slot_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "channel_mask" does not exist at character 20
STATEMENT:  SELECT MaskToArray(channel_mask) INTO channel_v;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN channel_v;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS LoopEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 			   	     sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION LoopEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 	      		 		sub_conf_name TEXT ) RETURNS SETOF INT[] AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS LoopEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 			   	     sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION LoopEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 	      		 		sub_conf_name TEXT ) RETURNS SETOF INT[] AS $$
	DECLARE
	  sub_conf_id INT;
ERROR:  syntax error at or near "crate_v" at character 1
STATEMENT:  crate_v   INT[];
ERROR:  syntax error at or near "slot_v" at character 1
STATEMENT:  slot_v    INT[];
ERROR:  syntax error at or near "channel_v" at character 1
STATEMENT:  channel_v INT[];
ERROR:  syntax error at or near "crate_id" at character 1
STATEMENT:  crate_id   INT;
ERROR:  syntax error at or near "slot_id" at character 1
STATEMENT:  slot_id    INT;
ERROR:  syntax error at or near "channel_id" at character 1
STATEMENT:  channel_id INT;
ERROR:  syntax error at or near "SELECT" at character 9
STATEMENT:  BEGIN
	  SELECT ListEnabledCrates(main_conf_name,sub_conf_name) INTO crate_v;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF crate_v IS NULL THEN
	    RAISE EXCEPTION '++++++++++++ Failed retrieving crate list! ++++++++++++++';
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "main_conf_name" does not exist at character 20
STATEMENT:  SELECT SubConfigID(main_conf_name, sub_conf_name) INTO sub_conf_id;
ERROR:  syntax error at or near "FOREACH" at character 1
STATEMENT:  FOREACH crate_id IN ARRAY crate_v LOOP
	    SELECT ListEnabledSlots(sub_conf_name,sub_conf_id,crate_id) INTO slot_v;
ERROR:  syntax error at or near "FOREACH" at character 1
STATEMENT:  FOREACH slot_id IN ARRAY slot_v LOOP
	      SELECT ListEnabledChannels(sub_conf_name,sub_conf_id,crate_id,slot_id) INTO channel_v;
ERROR:  syntax error at or near "FOREACH" at character 1
STATEMENT:  FOREACH channel_id IN ARRAY channel_v LOOP
	        RETURN NEXT ARRAY[crate_id,slot_id,channel_id];
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS PrintEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 	 		   	      sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION PrintEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 	      		 		 sub_conf_name TEXT ) RETURNS INT AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS PrintEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 	 		   	      sub_conf_name TEXT );
	
	CREATE OR REPLACE FUNCTION PrintEnabledCrateSlotChannel( main_conf_name TEXT,
	     	      	 	      		 		 sub_conf_name TEXT ) RETURNS INT AS $$
	DECLARE
	  enabled_combination INT[];
ERROR:  syntax error at or near "FOR" at character 9
STATEMENT:  BEGIN
	  FOR enabled_combination IN SELECT LoopEnabledCrateSlotChannel(main_conf_name,sub_conf_name) LOOP
	    RAISe INFO 'Enabled (Crate,Slot,Channel) = %',enabled_combination;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 1;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetCrateConfig( sub_conf_name TEXT,
	     	      	 			sub_conf_id   INT,
						crate_id      INT );
	
	CREATE OR REPLACE FUNCTION GetCrateConfig( sub_conf_name TEXT,
	     	      	 			   sub_conf_id   INT,
						   crate_id      INT ) RETURNS UnitConfig AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetCrateConfig( sub_conf_name TEXT,
	     	      	 			sub_conf_id   INT,
						crate_id      INT );
	
	CREATE OR REPLACE FUNCTION GetCrateConfig( sub_conf_name TEXT,
	     	      	 			   sub_conf_id   INT,
						   crate_id      INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
ERROR:  syntax error at or near "exist" at character 1
STATEMENT:  exist  BOOLEAN;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params UnitConfig;
ERROR:  syntax error at or near "rec" at character 1
STATEMENT:  rec    RECORD;
ERROR:  syntax error at or near "conf_params" at character 9
STATEMENT:  BEGIN
	  conf_params.Crate   := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Channel := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Params  := '';
ERROR:  syntax error at or near "INTO" at character 67
STATEMENT:  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Crate := crate_id;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate = %s OR Crate = -999) AND SLOT = -1 AND Channel = -1 ORDER BY Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id);
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN conf_params;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetSlotConfig( sub_conf_name TEXT,
	     	      	 		       sub_conf_id   INT,
					       crate_id      INT,
					       slot_id       INT );
	
	CREATE OR REPLACE FUNCTION GetSlotConfig( sub_conf_name TEXT,
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT,
						  slot_id       INT ) RETURNS UnitConfig AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetSlotConfig( sub_conf_name TEXT,
	     	      	 		       sub_conf_id   INT,
					       crate_id      INT,
					       slot_id       INT );
	
	CREATE OR REPLACE FUNCTION GetSlotConfig( sub_conf_name TEXT,
	     	      	 			  sub_conf_id   INT,
						  crate_id      INT,
						  slot_id       INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
ERROR:  syntax error at or near "exist" at character 1
STATEMENT:  exist  BOOLEAN;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params UnitConfig;
ERROR:  syntax error at or near "rec" at character 1
STATEMENT:  rec    RECORD;
ERROR:  syntax error at or near "slot_v" at character 1
STATEMENT:  slot_v INT[];
ERROR:  syntax error at or near "conf_params" at character 9
STATEMENT:  BEGIN
	  conf_params.Crate   := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Channel := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Params  := '';
ERROR:  syntax error at or near "INTO" at character 67
STATEMENT:  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "sub_conf_name" does not exist at character 25
STATEMENT:  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN conf_params;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Crate   := crate_id;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := slot_id;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id);
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN conf_params;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetChannelConfig( sub_conf_name TEXT,
	     	      	 		       	  sub_conf_id   INT,
					       	  crate_id      INT,
					       	  slot_id       INT,
						  channel_id    INT );
	
	CREATE OR REPLACE FUNCTION GetChannelConfig( sub_conf_name TEXT,
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT,
						     channel_id    INT ) RETURNS UnitConfig AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetChannelConfig( sub_conf_name TEXT,
	     	      	 		       	  sub_conf_id   INT,
					       	  crate_id      INT,
					       	  slot_id       INT,
						  channel_id    INT );
	
	CREATE OR REPLACE FUNCTION GetChannelConfig( sub_conf_name TEXT,
	     	      	 			     sub_conf_id   INT,
						     crate_id      INT,
						     slot_id       INT,
						     channel_id    INT ) RETURNS UnitConfig AS $$
	DECLARE
	  query  TEXT;
ERROR:  syntax error at or near "exist" at character 1
STATEMENT:  exist  BOOLEAN;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params UnitConfig;
ERROR:  syntax error at or near "rec" at character 1
STATEMENT:  rec    RECORD;
ERROR:  syntax error at or near "channel_v" at character 1
STATEMENT:  channel_v INT[];
ERROR:  syntax error at or near "conf_params" at character 9
STATEMENT:  BEGIN
	  conf_params.Crate   := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Channel := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Params  := '';
ERROR:  syntax error at or near "INTO" at character 67
STATEMENT:  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "sub_conf_name" does not exist at character 28
STATEMENT:  SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT ARRAY[channel_id] <@ channel_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot,Channel) = (%,%,%) is not enabled! ++++++++++++',crate_id,slot_id,channel_id;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN conf_params;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Crate   := crate_id;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := slot_id;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Channel := channel_id;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Params  := '';
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Channel = -999 OR (Crate = %s AND Slot = %s AND Channel = %s)) ORDER BY Channel ASC, Slot ASC, Crate ASC;',
	  	   	   sub_conf_name,
			   sub_conf_id,
			   crate_id,
			   slot_id,
			   channel_id);
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR rec IN EXECUTE query LOOP
	    conf_params.Params := conf_params.Params || rec.Parameters;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN conf_params;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 		       	      sub_conf_id   INT,
					       	      crate_id      INT,
					       	      slot_id       INT);
	
	CREATE OR REPLACE FUNCTION GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	 sub_conf_id   INT,
						     	 crate_id      INT,
						     	 slot_id       INT) RETURNS SETOF UnitConfig AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 		       	      sub_conf_id   INT,
					       	      crate_id      INT,
					       	      slot_id       INT);
	
	CREATE OR REPLACE FUNCTION GetSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	 sub_conf_id   INT,
						     	 crate_id      INT,
						     	 slot_id       INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
ERROR:  syntax error at or near "exist" at character 1
STATEMENT:  exist  BOOLEAN;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params UnitConfig;
ERROR:  syntax error at or near "params" at character 1
STATEMENT:  params HSTORE;
ERROR:  syntax error at or near "rec" at character 1
STATEMENT:  rec    RECORD;
ERROR:  syntax error at or near "rec_set" at character 1
STATEMENT:  rec_set RECORD;
ERROR:  syntax error at or near "slot_v" at character 1
STATEMENT:  slot_v    INT[];
ERROR:  syntax error at or near "channel_v" at character 1
STATEMENT:  channel_v INT[];
ERROR:  syntax error at or near "channel_id" at character 1
STATEMENT:  channel_id INT;
ERROR:  syntax error at or near "conf_params" at character 9
STATEMENT:  BEGIN
	  conf_params.Crate   := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Channel := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Params  := '';
ERROR:  syntax error at or near "INTO" at character 67
STATEMENT:  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "sub_conf_name" does not exist at character 25
STATEMENT:  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT ARRAY[slot_id] <@ slot_v THEN
	    RAISE NOTICE '++++++++++++ (Crate,Slot) = (%,%) is not enabled! ++++++++++++',crate_id,slot_id;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN NEXT conf_params;
ERROR:  syntax error at or near "ELSE" at character 1
STATEMENT:  ELSE
	    conf_params.Crate   := crate_id;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := slot_id;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Channel := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Params  := '';
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format( 'SELECT Parameters FROM %s WHERE ConfigID = %s AND (Slot = -999 OR (Crate = %s AND Slot = %s)) AND Channel = -1 ORDER BY Slot ASC, Crate ASC;',
	  	   	     sub_conf_name,
			     sub_conf_id,
			     crate_id,
			     slot_id);
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR rec IN EXECUTE query LOOP
	      conf_params.Params := conf_params.Params || rec.Parameters;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN NEXT conf_params;
ERROR:  column "sub_conf_name" does not exist at character 28
STATEMENT:  SELECT ListEnabledChannels(sub_conf_name, sub_conf_id, crate_id, slot_id) INTO channel_v;
ERROR:  syntax error at or near "FOREACH" at character 1
STATEMENT:  FOREACH channel_id IN ARRAY channel_v LOOP
	      SELECT GetChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id, channel_id) INTO rec;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params := rec.getchannelconfig;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN NEXT conf_params;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 		       	           sub_conf_id   INT,
					       	      	   crate_id      INT);
	
	CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	      sub_conf_id   INT,
						     	      crate_id      INT) RETURNS SETOF UnitConfig AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 		       	           sub_conf_id   INT,
					       	      	   crate_id      INT);
	
	CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( sub_conf_name TEXT,
	     	      	 			     	      sub_conf_id   INT,
						     	      crate_id      INT) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
ERROR:  syntax error at or near "exist" at character 1
STATEMENT:  exist  BOOLEAN;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params UnitConfig;
ERROR:  syntax error at or near "rec" at character 1
STATEMENT:  rec    RECORD;
ERROR:  syntax error at or near "rec_set" at character 1
STATEMENT:  rec_set RECORD;
ERROR:  syntax error at or near "slot_v" at character 1
STATEMENT:  slot_v    INT[];
ERROR:  syntax error at or near "slot_id" at character 1
STATEMENT:  slot_id   INT;
ERROR:  syntax error at or near "conf_params" at character 9
STATEMENT:  BEGIN
	  conf_params.Crate   := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Slot    := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Channel := -1;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params.Params  := '';
ERROR:  syntax error at or near "INTO" at character 67
STATEMENT:  SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = sub_conf_name INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not exist! ++++++++++++++',sub_conf_name;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID = %s',sub_conf_name,sub_conf_id);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO exist;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF exist IS NULL THEN
	    RAISE EXCEPTION '+++++++++++++ Sub-Config % does not have config ID %! ++++++++++++++',sub_conf_name,sub_conf_id;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  column "sub_conf_name" does not exist at character 23
STATEMENT:  SELECT GetCrateConfig(sub_conf_name, sub_conf_id, crate_id) INTO rec;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params := rec.getcrateconfig;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN NEXT conf_params;
ERROR:  column "sub_conf_name" does not exist at character 25
STATEMENT:  SELECT ListEnabledSlots(sub_conf_name, sub_conf_id, crate_id) INTO slot_v;
ERROR:  syntax error at or near "FOREACH" at character 1
STATEMENT:  FOREACH slot_id IN ARRAY slot_v LOOP
	    FOR rec IN SELECT GetSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id, slot_id) LOOP
	      conf_params := rec.GetSlotChannelConfig;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN NEXT conf_params;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 		       	           sub_conf_name  TEXT );
	
	CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 			     	      sub_conf_name  TEXT ) RETURNS SETOF UnitConfig AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	DROP FUNCTION IF EXISTS GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 		       	           sub_conf_name  TEXT );
	
	CREATE OR REPLACE FUNCTION GetCrateSlotChannelConfig( main_conf_name TEXT,
	     	      	 			     	      sub_conf_name  TEXT ) RETURNS SETOF UnitConfig AS $$
	DECLARE
	  query  TEXT;
ERROR:  syntax error at or near "sub_conf_id" at character 1
STATEMENT:  sub_conf_id INT;
ERROR:  syntax error at or near "crate_v" at character 1
STATEMENT:  crate_v INT[];
ERROR:  syntax error at or near "crate_id" at character 1
STATEMENT:  crate_id INT;
ERROR:  syntax error at or near "conf_params" at character 1
STATEMENT:  conf_params UnitConfig;
ERROR:  syntax error at or near "rec" at character 1
STATEMENT:  rec    RECORD;
ERROR:  syntax error at or near "SELECT" at character 9
STATEMENT:  BEGIN
	  SELECT SubConfigID( main_conf_name,sub_conf_name) INTO sub_conf_id;
ERROR:  column "main_conf_name" does not exist at character 27
STATEMENT:  SELECT ListEnabledCrates( main_conf_name, sub_conf_name ) INTO crate_v;
ERROR:  syntax error at or near "FOREACH" at character 1
STATEMENT:  FOREACH crate_id IN ARRAY crate_v LOOP
	    FOR rec in SELECT GetCrateSlotChannelConfig(sub_conf_name, sub_conf_id, crate_id) LOOP
	      conf_params := rec.GetCrateSlotChannelConfig;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN NEXT conf_params;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	CREATE OR REPLACE FUNCTION InsertMainConfiguration( subconfigparameters HSTORE,
	       	  	  	   			    subconfigmasks HSTORE,
	       	  	  	   			    confname text DEFAULT 'no_name') RETURNS INT AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	------------------------------------------------------------------------
	
	CREATE OR REPLACE FUNCTION InsertMainConfiguration( subconfigparameters HSTORE,
	       	  	  	   			    subconfigmasks HSTORE,
	       	  	  	   			    confname text DEFAULT 'no_name') RETURNS INT AS $$
	    DECLARE
	    myrec1 RECORD;
ERROR:  syntax error at or near "myrec2" at character 1
STATEMENT:  myrec2 RECORD;
ERROR:  syntax error at or near "myrec3" at character 1
STATEMENT:  myrec3 RECORD;
ERROR:  syntax error at or near "ColumnPair" at character 1
STATEMENT:  ColumnPair RECORD;
ERROR:  syntax error at or near "SubConfigCount" at character 1
STATEMENT:  SubConfigCount INT;
ERROR:  syntax error at or near "newconfig" at character 1
STATEMENT:  newconfig INT;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query text;
ERROR:  syntax error at or near "SubConfT" at character 1
STATEMENT:  SubConfT INT;
ERROR:  syntax error at or near "localconfigexists" at character 1
STATEMENT:  localconfigexists INT;
ERROR:  syntax error at or near "IF" at character 20
STATEMENT:  BEGIN    
	    
	    IF  (confname <> 'no_name' ) AND EXISTS (SELECT ConfigID FROM MainConfigTable WHERE MainConfigTable.ConfigName = confname)
	        THEN RAISE EXCEPTION '+++++++++++++ Config with name % already exists in MainConfigTable! +++++++++++++',confname;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN -1;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR ColumnPair IN SELECT (each(subconfigparameters)).*
	    LOOP
	        
	        
		IF NOT EXISTS ( SELECT TRUE FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key)
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % is not defined! +++++++++++++++', ColumnPair.key;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 1;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := format('SELECT TRUE FROM %s WHERE ConfigID=%s',ColumnPair.key,ColumnPair.value);
ERROR:  syntax error at or near "INTO" at character 15
STATEMENT:  EXECUTE query INTO myrec2;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF myrec2.bool IS NULL
		    THEN RAISE EXCEPTION '++++++++++++ Configuration % does not contain ConfigID=%++++++++++++',ColumnPair.key,ColumnPair.value;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 1;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT AKEYS(subconfigparameters) @> AKEYS(subconfigmasks) THEN
	      RAISE EXCEPTION '++++++++++++++ Mask contains configuration that is not in the list of subconfigurations! +++++++++++++';
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR ColumnPair IN SELECT (each(subconfigmasks)).*
	    LOOP
		SELECT textregexeq(ColumnPair.value,'^[0-1]+(\.[0-1]+)?$') AS VAL INTO myrec2;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT myrec2.VAL THEN
		  RAISE EXCEPTION '++++++++++++ Config % Mask % is not a valid binary expression +++++++++++++',ColumnPair.key,ColumnPair.value;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "INTO" at character 46
STATEMENT:  SELECT (each(subconfigparameters)).* LIMIT 1 INTO ColumnPair;
ERROR:  syntax error at or near "INTO" at character 78
STATEMENT:  SELECT  SubconfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
ERROR:  syntax error at or near "for" at character 1
STATEMENT:  for myrec3 IN SELECT DISTINCT configID FROM MainconfigTable WHERE SubConfigType = SubConfT AND SubConfigID = CAST(ColumnPair.value AS INT)
	      LOOP
	         
	
		 
		 SELECT COUNT(TRUE) FROM MainConfigTable WHERE ConfigID = myrec3.ConfigID INTO SubConfigCount;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT SubConfigCount = ARRAY_LENGTH(AKEYS(subconfigparameters),1)
		    THEN CONTINUE;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "localconfigexists" at character 1
STATEMENT:  localconfigexists := 1;
ERROR:  syntax error at or near "for" at character 1
STATEMENT:  for ColumnPair IN SELECT (each(subconfigparameters)).*
		     LOOP
		     SELECT SubConfigType FROM ConfigLookUp WHERE SubConfigName = ColumnPair.key INTO SubConfT;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF NOT EXISTS( SELECT TRUE FROM MainconfigTable WHERE SubConfigType = SubConfT AND subconfigid=CAST(ColumnPair.value AS INT) AND ConfigID=myrec3.ConfigID )
			  THEN localconfigexists := 0;
ERROR:  syntax error at or near "EXIT" at character 1
STATEMENT:  EXIT;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF localconfigexists = 1    
		    THEN RAISE EXCEPTION '+++++++++++++ This Configuration exists MainConfigTable, with ID: %! +++++++++++++',myrec3.ConfigID;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN -1;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "INTO" at character 69
STATEMENT:  SELECT configID FROM MainConfigTable ORDER BY configID DESC LIMIT 1 INTO newconfig ;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF newconfig IS NULL
	      THEN  newconfig := 0;
ERROR:  syntax error at or near "ELSE" at character 1
STATEMENT:  ELSE
	       newconfig := newconfig + 1;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "RAISE" at character 1
STATEMENT:  RAISE NOTICE 'Inserting a new entry in MainConfigTable: Name=% ... ID=%',confname,newconfig;
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR myrec1 IN SELECT (each(subconfigparameters)).*
	    LOOP
	    SELECT SubconfigType FROM ConfigLookUp WHERE SubConfigName = myrec1.key INTO SubConfT;
ERROR:  column "subconfigmasks" does not exist at character 8
STATEMENT:  SELECT subconfigmasks->myrec1.key AS VAL INTO myrec2;
ERROR:  syntax error at or near "IF" at character 1
STATEMENT:  IF myrec2.VAL IS NULL THEN
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      '111111111111'::BIT(64),
					      confname);
ERROR:  syntax error at or near "ELSE" at character 1
STATEMENT:  ELSE
	      INSERT INTO MainconfigTable ( ConfigID,
	    	   			    SubConfigType,
					    SubConfigID, 
					    SubConfigMask,
					    ConfigName) VALUES
					    ( newconfig, SubConfT, CAST(myrec1.value AS INT), 
					      CAST(myrec2.VAL AS BIT(64)),
					      confname);
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN newconfig;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	CREATE OR REPLACE FUNCTION CleanSubConfigurationID( cfg_name TEXT,
	       	  	  	   		            cfg_id   INT) RETURNS INT AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	CREATE OR REPLACE FUNCTION CleanSubConfigurationID( cfg_name TEXT,
	       	  	  	   		            cfg_id   INT) RETURNS INT AS $$
	DECLARE
	query TEXT;
ERROR:  syntax error at or near "IF" at character 11
STATEMENT:  BEGIN
	    IF ExistSubConfig(cfg_name) THEN
	      query := 'DELETE FROM ' || cfg_name || ' WHERE ConfigID = ' || cfg_id;
ERROR:  prepared statement "query" does not exist
STATEMENT:  EXECUTE query;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 1;
ERROR:  syntax error at or near "ELSE" at character 1
STATEMENT:  ELSE
	      RETURN 0;
ERROR:  syntax error at or near "IF" at character 5
STATEMENT:  END IF;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 0;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------
	
	CREATE OR REPLACE FUNCTION CleanConfigDB() RETURNS INT AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	-------------------------------------------------------------
	
	CREATE OR REPLACE FUNCTION CleanConfigDB() RETURNS INT AS $$
	DECLARE
	  ConfigTable RECORD;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query TEXT;
ERROR:  syntax error at or near "DELETE" at character 11
STATEMENT:  BEGIN
	    DELETE FROM MainConfigTable;
ERROR:  syntax error at or near "FOR" at character 1
STATEMENT:  FOR ConfigTable IN SELECT DISTINCT SubConfigName FROM ConfigLookUp
	    LOOP
	        query := 'DROP TABLE IF EXISTS '||ConfigTable.SubConfigName||';';
ERROR:  prepared statement "query" does not exist
STATEMENT:  EXECUTE query;
ERROR:  syntax error at or near "LOOP" at character 5
STATEMENT:  END LOOP;
ERROR:  syntax error at or near "RETURN" at character 1
STATEMENT:  RETURN 0;
WARNING:  there is no transaction in progress
ERROR:  syntax error at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	DROP FUNCTION IF EXISTS GetSubConfig( text, INT) ;
	
	------------------create TYPES for each table?
	
	
	
	-- at least one line with the configuration must exist
	CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	DROP FUNCTION IF EXISTS GetSubConfig( text, INT) ;
	
	------------------create TYPES for each table?
	
	
	
	-- at least one line with the configuration must exist
	CREATE OR REPLACE FUNCTION GetSubConfig(tablename text,mainconfigid INT) RETURNS SETOF subconfigreturntype AS $$
	    DECLARE
	    myrec RECORD;
ERROR:  syntax error at or near "conftype" at character 1
STATEMENT:  conftype ConfigLookUp.SubConfigType%TYPE;
ERROR:  syntax error at or near "mainconfrow" at character 1
STATEMENT:  mainconfrow mainconfigtable%ROWTYPE;
ERROR:  syntax error at or near "subconfigconfigrec" at character 1
STATEMENT:  subconfigconfigrec subconfigreturntype;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query   text;
ERROR:  syntax error at or near "testquery" at character 1
STATEMENT:  testquery text;
ERROR:  syntax error at or near "mainconfquery" at character 1
STATEMENT:  mainconfquery text;
ERROR:  syntax error at or near "RAISE" at character 22
STATEMENT:  BEGIN
	        
	      RAISE INFO 'subconfigid % ', tablename;
ERROR:  syntax error at or near "testquery" at character 1
STATEMENT:  testquery :='SELECT  SubConfigType FROM ConfigLookup WHERE ConfigLookup.SubConfigName=' || quote_literal(tablename);
ERROR:  syntax error at or near "RAISE" at character 1
STATEMENT:  RAISE INFO 'testquery % ', testquery;
ERROR:  syntax error at or near "INTO" at character 19
STATEMENT:  EXECUTE testquery INTO conftype;
ERROR:  syntax error at or near "RAISE" at character 1
STATEMENT:  RAISE INFO 'SELECTED % ', conftype;
ERROR:  syntax error at or near "mainconfquery" at character 1
STATEMENT:  mainconfquery :='SELECT  * FROM mainconfigtable WHERE subconfigtype=' || conftype || ' AND configid='||mainconfigid;
ERROR:  syntax error at or near "RAISE" at character 1
STATEMENT:  RAISE INFO ' % ', mainconfquery ;
ERROR:  syntax error at or near "INTO" at character 23
STATEMENT:  EXECUTE mainconfquery INTO mainconfrow;
ERROR:  syntax error at or near "RAISE" at character 1
STATEMENT:  RAISE INFO 'conf: %  , subconf: %   ,  parent: %  ', mainconfrow.configid, mainconfrow.subconfigid ,  mainconfrow.subconfigparentid ;
ERROR:  syntax error at or near "query" at character 1
STATEMENT:  query := 'SELECT * FROM ' || tablename || ' WHERE ' || tablename || '.configid =' || mainconfrow.subconfigparentid ;
ERROR:  syntax error at or near "for" at character 1
STATEMENT:  for subconfigconfigrec in EXECUTE query loop
	      subconfigconfigrec.ConfigName:=tablename;
ERROR:  syntax error at or near "subconfigconfigrec" at character 1
STATEMENT:  subconfigconfigrec.ConfigType:=conftype;
ERROR:  syntax error at or near "return" at character 1
STATEMENT:  return next subconfigconfigrec;
ERROR:  syntax error at or near "loop" at character 5
STATEMENT:  end loop;
ERROR:  syntax error at or near "return" at character 1
STATEMENT:  return;
WARNING:  there is no transaction in progress
ERROR:  unterminated dollar-quoted string at or near "$$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	" at character 1
STATEMENT:  $$ LANGUAGE plpgsql VOLATILE STRICT;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
ERROR:  syntax error at or near "pmt_fem_mod" at character 6
STATEMENT:  DROP pmt_fem_mod;
ERROR:  syntax error at or near "ConfigLookUp" at character 10
STATEMENT:  SELECT * ConfigLookUp
	;
ERROR:  column "sub_conf_name" does not exist at character 41
QUERY:  SELECT                    SubConfigType(sub_conf_name)
CONTEXT:  PL/pgSQL function cleansubconfigurationid(text,integer) line 8 at SQL statement
STATEMENT:  SELECT CleanSubConfigurationID('pmt_fem_mod',2);
ERROR:  query string argument of EXECUTE is null
CONTEXT:  PL/pgSQL function cleansubconfigurationid(text,integer) line 21 at EXECUTE statement
STATEMENT:  SELECT CleanSubConfigurationID('pmt_fem_mod',2);
ERROR:  syntax error at or near ";" at character 47
STATEMENT:  SELECT CleanSubConfigurationID('pmt_fem_mod',2;
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 2 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,2::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  function checknewcrateconfiguration(text, integer, integer, integer, integer, hstore) does not exist at character 8
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  SELECT CheckNewCrateConfiguration(config_name, config_id, crate_id, slot_id, channel_id, params) AS VAL
CONTEXT:  PL/pgSQL function fillsubconfiguration(text,integer,integer,integer,integer,bit,hstore) line 7 at SQL statement
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, -999::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "name"=>"" '::HSTORE); 
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, -999::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "name"=>"" '::HSTORE); 
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, -999::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "name"=>"" '::HSTORE); 
ERROR:  Syntax error near 'P' at position 274 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, 10::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE); 
ERROR:  Syntax error near 'P' at position 274 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, 10::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE); 
ERROR:  Syntax error near 'P' at position 274 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, 10::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE); 
ERROR:  column "'aho'=>'boke'" does not exist at character 8
STATEMENT:  SELECT "'aho'=>'boke'"::HSTORE;
ERROR:  syntax error at or near "SELECT" at character 15
STATEMENT:  SELECT '\'aho
	SELECT 'aho=>boke'::HSTORE;
ERROR:  Unexpected end of string at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, 10::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000'::HSTORE);
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, 10::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),' "circular_buffer_size"=>"10e9"'::HSTORE);
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, 10::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'circular_buffer_size=>10e9'::HSTORE);
ERROR:  +++++++++ Invalid subconfiguration! Aborting +++++++++
STATEMENT:  SELECT FillSubConfiguration('pmt_fem_mod'::TEXT, 2::INT, 10::INT, -1::INT, -1::INT,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'circular_buffer_size=>10e9'::HSTORE);
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 2 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,2::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 2 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,2::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 4 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,4::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 5 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,5::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 9 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,9::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  unexpected end of function definition at end of input at character 473
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	DECLARE
	  exist BOOLEAN;
	  ctr INT;
	  query TEXT;
	BEGIN
	   SELECT INTO exist ExistSubConfig(SCfgName);
	   ctr := 0;
	   IF exist THEN
	     query := 'SELECT 1 FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	     EXECUTE query INTO ctr;
	     RETURN ctr;
	   RETURN 0;
	     
	   SELECT COUNT(SubConfigType) FROM ConfigLookUp WHERE SubConfigName = SCfgName AND ConfigID = SCfgID LIMIT 1
	END
	$$ LANGUAGE plpgsql VOLATILE;
ERROR:  function existsubconfigid(unknown, integer) does not exist at character 15
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT * FROM ExistSubConfigID('pmt_fem_mod',5);
ERROR:  function existsubconfig(unknown, integer) does not exist at character 15
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT * FROM ExistSubConfig('pmt_fem_mod',5);
ERROR:  unexpected end of function definition at end of input at character 473
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	DECLARE
	  exist BOOLEAN;
	  ctr INT;
	  query TEXT;
	BEGIN
	   SELECT INTO exist ExistSubConfig(SCfgName);
	   ctr := 0;
	   IF exist THEN
	     query := 'SELECT 1 FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	     EXECUTE query INTO ctr;
	     RETURN ctr;
	   RETURN 0;
	     
	   SELECT COUNT(SubConfigType) FROM ConfigLookUp WHERE SubConfigName = SCfgName AND ConfigID = SCfgID LIMIT 1
	END
	$$ LANGUAGE plpgsql VOLATILE;
ERROR:  syntax error at or near "END" at character 469
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	DECLARE
	  exist BOOLEAN;
	  ctr INT;
	  query TEXT;
	BEGIN
	   SELECT INTO exist ExistSubConfig(SCfgName);
	   ctr := 0;
	   IF exist THEN
	     query := 'SELECT 1 FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	     EXECUTE query INTO ctr;
	     RETURN ctr;
	   RETURN 0;
	     
	   SELECT COUNT(SubConfigType) FROM ConfigLookUp WHERE SubConfigName = SCfgName AND ConfigID = SCfgID LIMIT 1
	END;
	$$ LANGUAGE plpgsql;
ERROR:  syntax error at or near ";" at character 356
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT) RETURNS INT AS $$
	DECLARE
	  exist BOOLEAN;
	  ctr INT;
	  query TEXT;
	BEGIN
	   SELECT INTO exist ExistSubConfig(SCfgName);
	   ctr := 0;
	   IF exist THEN
	     query := 'SELECT 1 FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	     EXECUTE query INTO ctr;
	     RETURN ctr;
	   RETURN 0;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  syntax error at or near ";" at character 368
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT, SCfgID INT) RETURNS INT AS $$
	DECLARE
	  exist BOOLEAN;
	  ctr INT;
	  query TEXT;
	BEGIN
	   SELECT INTO exist ExistSubConfig(SCfgName);
	   ctr := 0;
	   IF exist THEN
	     query := 'SELECT 1 FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	     EXECUTE query INTO ctr;
	     RETURN ctr;
	   RETURN 0;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  syntax error at or near ";" at character 368
STATEMENT:  CREATE OR REPLACE FUNCTION ExistSubConfig(SCfgName TEXT, SCfgID INT) RETURNS INT AS $$
	DECLARE
	  exist BOOLEAN;
	  ctr INT;
	  query TEXT;
	BEGIN
	   SELECT INTO exist ExistSubConfig(SCfgName);
	   ctr := 0;
	   IF exist THEN
	     query := 'SELECT 1 FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	     EXECUTE query INTO ctr;
	     RETURN ctr;
	   RETURN 0;
	END;
	$$ LANGUAGE plpgsql;
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 9 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,9::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  argument of NOT must be type boolean, not type integer at character 12
QUERY:  SELECT NOT ctr
CONTEXT:  PL/pgSQL function existsubconfig(text,integer) line 12 at IF
STATEMENT:  SELECT * FROM ExistSubConfig('pmt_fem_mod',20);
ERROR:  ++++++++++ Configuration pmt_fem_mod with ID 9 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_fem_mod'::TEXT,9::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64),'1111111111111111000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration Type pmt_fem_mod Already Exists +++++++++++
STATEMENT:  SELECT CreateSubConfiguration('pmt_fem_mod');
ERROR:  Unexpected end of string at character 59
STATEMENT:  SELECT InsertMainConfiguration('"pmt_fem_mod"=>'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000\"'::HSTORE,main_test);
ERROR:  column "main_test" does not exist at character 157
STATEMENT:  SELECT InsertMainConfiguration('\"pmt_fem_mod\"=>'::HSTORE,'\"pmt_fem_mod\"=>\"0000000000000000000000000000000000000000000000000000000000000000\"'::HSTORE,main_test);
ERROR:  ++++++++++++ Configuration "pmt_fem_mod" is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('\"pmt_fem_mod\"=>'::HSTORE,'\"pmt_fem_mod\"=>\"0000000000000000000000000000000000000000000000000000000000000000\"'::HSTORE,'main_test');
ERROR:  ++++++++++++ Configuration "pmt_fem_mod" is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('\"pmt_fem_mod\"=>'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000"'::HSTORE,'main_test');
ERROR:  ++++++++++++ Configuration "pmt_fem_mod" is not defined! +++++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('\"pmt_fem_mod\"=>'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000"'::HSTORE,'main_test');
ERROR:  syntax error at or near "" at character 45
QUERY:  SELECT TRUE FROM pmt_fem_mod WHERE ConfigID=
CONTEXT:  PL/pgSQL function insertmainconfiguration(hstore,hstore,text) line 34 at EXECUTE statement
STATEMENT:  SELECT InsertMainConfiguration('"pmt_fem_mod"=>'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000"'::HSTORE,'main_test');
ERROR:  unrecognized conversion specifier "d"
CONTEXT:  PL/pgSQL function insertmainconfiguration(hstore,hstore,text) line 33 at assignment
STATEMENT:  SELECT InsertMainConfiguration('"pmt_fem_mod"=>'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000"'::HSTORE,'main_test');
ERROR:  syntax error at or near "" at character 45
QUERY:  SELECT TRUE FROM pmt_fem_mod WHERE ConfigID=
CONTEXT:  PL/pgSQL function insertmainconfiguration(hstore,hstore,text) line 35 at EXECUTE statement
STATEMENT:  SELECT InsertMainConfiguration('"pmt_fem_mod"=>'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000"'::HSTORE,'main_test');
ERROR:  +++++++++++++ Config with name main_test already exists in MainConfigTable! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('"pmt_fem_mod"=>5'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000"'::HSTORE,'main_test');
ERROR:  column "main_test" does not exist at character 57
STATEMENT:  SELECT ConfigID FROM MainConfigTable WHERE ConfigName = main_test;
ERROR:  +++++++++++++ Config with name main_test already exists in MainConfigTable! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('"pmt_fem_mod"=>5'::HSTORE,'"pmt_fem_mod"=>"0000000000000000000000000000000000000000000000000000000000000000"'::HSTORE,'main_test');
ERROR:  invalid input syntax for type boolean: "2"
CONTEXT:  PL/pgSQL function existsubconfig(text,integer) line 7 at SQL statement
STATEMENT:  SELECT ExistSubConfig('tpc_fem_mod',5);
ERROR:  invalid input syntax for type boolean: "2"
CONTEXT:  PL/pgSQL function existsubconfig(text,integer) line 7 at SQL statement
STATEMENT:  SELECT ExistSubConfig('tpc_fem_mod',5);
ERROR:  invalid input syntax for type boolean: "2"
CONTEXT:  PL/pgSQL function existsubconfig(text,integer) line 7 at SQL statement
STATEMENT:  SELECT ExistSubConfig('tpc_fem_mod',5);
ERROR:  invalid input syntax for type boolean: "2"
CONTEXT:  PL/pgSQL function existsubconfig(text,integer) line 7 at SQL statement
STATEMENT:  SELECT ExistSubConfig('tpc_fem_mod',5);
ERROR:  invalid input syntax for type boolean: "2"
CONTEXT:  PL/pgSQL function existsubconfig(text,integer) line 7 at SQL statement
STATEMENT:  SELECT ExistSubConfig('tpc_fem_mod',5);
ERROR:  ++++++++++ Configuration tpc_fem_mod with ID 0 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('tpc_fem_mod'::TEXT,0::INT,' "circular_buffer_size"=>"2e9", "dma_buffer_size"=>"12700", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma", "port"=>"38300", "recipe"=>"Calibration", "shmKey"=>"38300", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>"\"TPC\"" '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000111111111111111'::BIT(64),'1111111111111111111111111111111111111111111111111111111111111111'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000001'::BIT(64));
ERROR:  relation "pmt_fem_config" does not exist at character 15
STATEMENT:  SELECT * FROm pmt_fem_config;
ERROR:  relation "pmt_fem_config" does not exist at character 15
STATEMENT:  SELECT * FROM pmt_fem_config;
ERROR:  relation "physics2" does not exist at character 15
STATEMENT:  SELECT * FROM physics2;
ERROR:  ++++++++++ Configuration pmt_config does not exist! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,1::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000111110000'::BIT(64),'0000000000000000000000001111111111111111111111111111111111111111'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_config does not exist! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,1::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000111110000'::BIT(64),'0000000000000000000000001111111111111111111111111111111111111111'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_config with ID 1 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,1::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000111110000'::BIT(64),'0000000000000000000000001111111111111111111111111111111111111111'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_config with ID 2 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,2::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000111110000'::BIT(64),'0000000000000000000000001111111111111111111111111111111111111111'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  ++++++++++ Configuration pmt_config with ID 3 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,3::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000111110000'::BIT(64),'0000000000000000000000001111111111111111111111111111111111111111'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  relation "mainrunconfig" does not exist at character 13
STATEMENT:  DELETE FROM MainRunConfig WHERE ConfigName='test';
ERROR:  ++++++++++++ Main Config = test2, Sub-Config = pmt_config not found in MainConfigTable! +++++++++++++++
CONTEXT:  SQL statement "SELECT SubConfigID( main_conf_name,sub_conf_name)"
	PL/pgSQL function getcrateslotchannelconfig(text,text) line 11 at SQL statement
STATEMENT:  SELECT * FROM GetCrateSlotChannelConfig('test2','pmt_config');
ERROR:  relation "mainrunconfig" does not exist at character 15
STATEMENT:  SELECT * FROM MainRunConfig;
ERROR:  ++++++++++++ Main Config = test2, Sub-Config = pmt_config not found in MainConfigTable! +++++++++++++++
CONTEXT:  SQL statement "SELECT SubConfigID( main_conf_name,sub_conf_name)"
	PL/pgSQL function getcrateslotchannelconfig(text,text) line 11 at SQL statement
STATEMENT:  SELECT * FROM GetCrateSlotChannelConfig('test2','pmt_config');
ERROR:  function getcrateslotconfig(unknown, unknown) does not exist at character 15
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT * FROM GetCrateSlotConfig('test1','pmt_config');
ERROR:  +++++++++++++ This Configuration exists MainConfigTable, with ID: 5! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('"pmt_config"=>10,"tpc_config"=>10'::HSTORE,'"pmt_config"=>"0000000000000000000000000000000000000000000000000000001000000000","tpc_config"=>"0000000000000000000000000000000000000000000000000000001111111111"'::HSTORE,'test2');
ERROR:  FOREACH expression must not be null
CONTEXT:  PL/pgSQL function getcrateslotchannelconfig(text,integer,integer) line 34 at FOREACH over array
	PL/pgSQL function getcrateslotchannelconfig(text,text) line 14 at FOR over SELECT rows
STATEMENT:  SELECT * FROM GetCrateSlotChannelConfig('test3','pmt_config');
ERROR:  ++++++++++++ Main Config = test2, Sub-Config = pmt_config not found in MainConfigTable! +++++++++++++++
CONTEXT:  SQL statement "SELECT SubConfigID( main_conf_name,sub_conf_name)"
	PL/pgSQL function getcrateslotchannelconfig(text,text) line 11 at SQL statement
STATEMENT:  SELECT * FROM GetCrateSlotChannelConfig('test2','pmt_config');
ERROR:  column "mainconfigtable" does not exist at character 8
STATEMENT:  SELECT MainConfigTable;
ERROR:  FOREACH expression must not be null
CONTEXT:  PL/pgSQL function getcrateslotchannelconfig(text,integer,integer) line 34 at FOREACH over array
	PL/pgSQL function getcrateslotchannelconfig(text,text) line 14 at FOR over SELECT rows
STATEMENT:  SELECT * FROM GetCrateSlotChannelConfig('test3','pmt_config');
ERROR:  syntax error at or near "ListEnabledCrates" at character 1
STATEMENT:  ListEnabledCrates('test3','pmt_config');
ERROR:  +++++++++++++ This Configuration exists MainConfigTable, with ID: 6! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('"pmt_config"=>11,"tpc_config"=>10'::HSTORE,'"pmt_config"=>"0000000000000000000000000000000000000000000000000000010000000000","tpc_config"=>"0000000000000000000000000000000000000000000000000000001111111111"'::HSTORE,'test4');
ERROR:  +++++++++++++ This Configuration exists MainConfigTable, with ID: 6! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('"pmt_config"=>11,"tpc_config"=>10'::HSTORE,'"pmt_config"=>"0000000000000000000000000000000000000000000000000000010000000000","tpc_config"=>"0000000000000000000000000000000000000000000000000000001111111111"'::HSTORE,'test5');
ERROR:  +++++++++++++ This Configuration exists MainConfigTable, with ID: 6! +++++++++++++
STATEMENT:  SELECT InsertMainConfiguration('"pmt_config"=>11,"tpc_config"=>10'::HSTORE,'"pmt_config"=>"0000000000000000000000000000000000000000000000000000010000000000","tpc_config"=>"0000000000000000000000000000000000000000000000000000001111111111"'::HSTORE,'test5');
ERROR:  FOREACH expression must not be null
CONTEXT:  PL/pgSQL function getslotchannelconfig(text,integer,integer,integer) line 54 at FOREACH over array
	PL/pgSQL function getcrateslotchannelconfig(text,integer,integer) line 36 at FOR over SELECT rows
	PL/pgSQL function getcrateslotchannelconfig(text,text) line 14 at FOR over SELECT rows
STATEMENT:  SELECT * FROM GetCrateSlotChannelConfig('test4','pmt_config');
ERROR:  syntax error at or near "%" at character 24
STATEMENT:  SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate=10 OR Crate<0) AND (Slot=4 OR Slot<0) AND (Channel=0 OR Channel<0 ORDER BY Channel ASC, Slot ASC, Crate ASC LIMIT 1;
	)
	;
ERROR:  syntax error at or near "%" at character 24
STATEMENT:  SELECT Parameters FROM %s WHERE ConfigID = %s AND (Crate=10 OR Crate<0) AND (Slot=4 OR Slot<0) AND (Channel=0 OR Channel<0) ORDER BY Channel ASC, Slot ASC, Crate ASC LIMIT 1;
ERROR:  syntax error at or near "%" at character 52
STATEMENT:  SELECT Parameters FROM pmt_config WHERE ConfigID = %s AND (Crate=10 OR Crate<0) AND (Slot=4 OR Slot<0) AND (Channel=0 OR Channel<0) ORDER BY Channel ASC, Slot ASC, Crate ASC LIMIT 1;
ERROR:  syntax error at or near "%" at character 24
STATEMENT:  SELECT Parameters FROM %s WHERE 
	         ConfigID = %s AND 
	;
ERROR:  syntax error at or near "WHERE" at character 59
STATEMENT:  SELECT * FROM MainConfigTable AS A JOIN ConfigLookUp AS B WHERE A.SubConfigType = B.SubConfigType;
ERROR:  relation "lateral" does not exist at character 64
STATEMENT:  SELECT * FROM GetCrateSlotChannelConfig('test4','pmt_config'), LATERAL each(params);
ERROR:  Unexpected end of string at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 13::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>"\"PMT\"", "name"=> '::HSTORE); 
ERROR:  ++++++++++ Configuration pmt_config with ID 13 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,13::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  Unexpected end of string at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 14::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>"\"PMT\"", "name"=> '::HSTORE); 
ERROR:  syntax error at or near "InsertSubConfiguration" at character 1
STATEMENT:  InsertSubConfiguration('pmt_config'::TEXT,14::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  Unexpected end of string at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 14::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>"\"PMT\"", "name"=> '::HSTORE);
ERROR:  ++++++++++ Configuration pmt_config with ID 15 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,15::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  Syntax error near 'P' at position 274 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 16::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE); 
ERROR:  Syntax error near 'P' at position 274 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 16::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE); 
ERROR:  Syntax error near 'P' at position 274 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 16::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE);
ERROR:  Syntax error near 'P' at position 274 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 16::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE);
ERROR:  Syntax error near 'P' at position 274 at character 161
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 16::INT, 10::INT, -1::INT, -1::INT, '0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>""PMT"", "name"=>"" '::HSTORE);
ERROR:  ++++++++++ Configuration pmt_config with ID 16 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,16::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
ERROR:  Syntax error near '\' at position 279 at character 160
STATEMENT:  SELECT FillSubConfiguration('pmt_config'::TEXT, 17::INT, 10::INT, -1::INT, -1::INT,'0000000000000000000000000000000000000000000000000000000111111000'::BIT(64),' "circular_buffer_size"=>"10e9", "dma_buffer_size"=>"120000", "fragment_id"=>"1", "nu_stream_sink"=>"assembler", "nu_stream_source"=>"dma_pmt", "port"=>"31423", "recipe"=>"onepmtcard", "sn_stream_sink"=>"NONE", "sn_stream_source"=>"NONE", "trigger_source"=>"INT", "type"=>"\"PMT"\", "name"=>"" '::HSTORE); 
ERROR:  ++++++++++ Configuration pmt_config with ID 18 is already defined! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('pmt_config'::TEXT,18::INT,' '::HSTORE,' '::HSTORE,' '::HSTORE,'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64),'0000000000000000000000000000000000000000000000000000000000000000'::BIT(64));
LOG:  database system was interrupted; last known up at 2015-06-19 09:17:32 CDT
LOG:  database system was not properly shut down; automatic recovery in progress
LOG:  record with zero length at 0/2424108
LOG:  redo is not required
LOG:  database system is ready to accept connections
LOG:  autovacuum launcher started
ERROR:  loop variable of loop over rows must be a record or row variable or list of scalar variables at character 497
STATEMENT:  CREATE OR REPLACE FUNCTION ListParameters(SubConfigName TEXT, SubConfigID INT)
	       	  	  RETURNS TABLE (ParamName TEXT, ParamValue TEXT) AS $$
	DECLARE
	  myquery TEXT;
	  params HSTORE;
	BEGIN
	  IF NOT ExistSubConfig(SubConfigName, SubConfigID) THEN
	    RAISE EXCEPTION '+++++++++ SubConfig % with ID % does not exist!  +++++++++', SCfgName, SCfgID;
	  END IF;
	
	  myquery := 'SELECT Parameters FROM ' || SubConfigName || ' WHERE ConfigID = ' || SfgID || ';';
	  EXECUTE myquery INTO params;
	
	  FOR pair IN SELECT (each(params)).*
	  LOOP
	    RETURN QUERY SELECT pair.key::TEXT, pair.value::TEXT;
	  END LOOP;
	  RETURN;
	END;
	$$ LANGUAGE PLPGSQL;
ERROR:  parameter name "subconfigname" used more than once
CONTEXT:  compilation of PL/pgSQL function "listparametersets" near line 1
STATEMENT:  CREATE OR REPLACE FUNCTION ListParameterSets(SubConfigName TEXT, SubConfigID INT)
	       	  	  RETURNS TABLE (SubConfigName TEXT, SubConfigID INT) AS $$
	DECLARE
	  myquery TEXT;
	  psets HSTORE;
	BEGIN
	  IF NOT ExistSubConfig(SubConfigName, SubConfigID) THEN
	    RAISE EXCEPTION '+++++++++ SubConfig % with ID % does not exist!  +++++++++', SCfgName, SCfgID;
	  END IF;
	
	  myquery := 'SELECT ParameterSets FROM ' || SubConfigName || ' WHERE ConfigID = ' || SfgID || ';';
	  EXECUTE myquery INTO psets;
	
	  FOR pair IN SELECT (each(psets)).*
	  LOOP
	    RETURN QUERY SELECT pair.key::TEXT, pair.value::INT;
	  END LOOP;
	  RETURN;
	END;
	$$ LANGUAGE PLPGSQL;
ERROR:  parameter name "subconfigname" used more than once
CONTEXT:  compilation of PL/pgSQL function "listparametersets" near line 1
STATEMENT:  CREATE OR REPLACE FUNCTION ListParameterSets(SubConfigName TEXT, SubConfigID INT)
	       	  	  RETURNS TABLE (SubConfigName TEXT, SubConfigID INT) AS $$
	DECLARE
	  myquery  TEXT;
	  psets  HSTORE;
	  pair   RECORD;
	BEGIN
	  IF NOT ExistSubConfig(SubConfigName, SubConfigID) THEN
	    RAISE EXCEPTION '+++++++++ SubConfig % with ID % does not exist!  +++++++++', SCfgName, SCfgID;
	  END IF;
	
	  myquery := 'SELECT ParameterSets FROM ' || SubConfigName || ' WHERE ConfigID = ' || SfgID || ';';
	  EXECUTE myquery INTO psets;
	
	  FOR pair IN SELECT (each(psets)).*
	  LOOP
	    RETURN QUERY SELECT pair.key::TEXT, pair.value::INT;
	  END LOOP;
	  RETURN;
	END;
	$$ LANGUAGE PLPGSQL;
ERROR:  cannot change name of input parameter "subconfigname"
HINT:  Use DROP FUNCTION first.
STATEMENT:  CREATE OR REPLACE FUNCTION ListParameters(SCfgName TEXT, SCfgID INT)
	       	  	  RETURNS TABLE (ParamName TEXT, ParamValue TEXT) AS $$
	DECLARE
	  myquery TEXT;
	  params HSTORE;
	  pair   RECORD;
	BEGIN
	  IF NOT ExistSubConfig(SubConfigName, SubConfigID) THEN
	    RAISE EXCEPTION '+++++++++ SubConfig % with ID % does not exist!  +++++++++', SCfgName, SCfgID;
	  END IF;
	
	  myquery := 'SELECT Parameters FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	  EXECUTE myquery INTO params;
	
	  FOR pair IN SELECT (each(params)).*
	  LOOP
	    RETURN QUERY SELECT pair.key::TEXT, pair.value::TEXT;
	  END LOOP;
	  RETURN;
	END;
	$$ LANGUAGE PLPGSQL;
ERROR:  cannot change name of input parameter "subconfigname"
HINT:  Use DROP FUNCTION first.
STATEMENT:  CREATE OR REPLACE FUNCTION ListParameters(SCfgName TEXT, SCfgID INT)
	       	  	  RETURNS TABLE (ParamName TEXT, ParamValue TEXT) AS $$
	DECLARE
	  myquery TEXT;
	  params HSTORE;
	  pair   RECORD;
	BEGIN
	  IF NOT ExistSubConfig(SCfgName, SCfgID) THEN
	    RAISE EXCEPTION '+++++++++ SubConfig % with ID % does not exist!  +++++++++', SCfgName, SCfgID;
	  END IF;
	
	  myquery := 'SELECT Parameters FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	  EXECUTE myquery INTO params;
	
	  FOR pair IN SELECT (each(params)).*
	  LOOP
	    RETURN QUERY SELECT pair.key::TEXT, pair.value::TEXT;
	  END LOOP;
	  RETURN;
	END;
	$$ LANGUAGE PLPGSQL;
ERROR:  cannot change name of input parameter "subconfigname"
HINT:  Use DROP FUNCTION first.
STATEMENT:  CREATE OR REPLACE FUNCTION ListParameters(SCfgName TEXT, SCfgID INT)
	       	  	  RETURNS TABLE (ParamName TEXT, ParamValue TEXT) AS $$
	DECLARE
	  myquery TEXT;
	  params HSTORE;
	  pair   RECORD;
	BEGIN
	  IF NOT ExistSubConfig(SCfgName, SCfgID) THEN
	    RAISE EXCEPTION '+++++++++ SubConfig % with ID % does not exist!  +++++++++', SCfgName, SCfgID;
	  END IF;
	
	  myquery := 'SELECT Parameters FROM ' || SCfgName || ' WHERE ConfigID = ' || SCfgID || ';';
	  EXECUTE myquery INTO params;
	
	  FOR pair IN SELECT (each(params)).*
	  LOOP
	    RETURN QUERY SELECT pair.key::TEXT, pair.value::TEXT;
	  END LOOP;
	  RETURN;
	END;
	$$ LANGUAGE PLPGSQL;
ERROR:  function listmainconfig() does not exist at character 15
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT * FROM ListMainConfig();
WARNING:  ++++++++++++ Sub-Config kazus w/ ID 1 currently in use within MainConfigTable! ++++++++++++
ERROR:  ++++++++++ Configuration tako does not exist! +++++++++++
STATEMENT:  SELECT InsertSubConfiguration('tako',1,' "buffer_size"=>"1e6", "slot"=>"0xc000", '::HSTORE,' '::HSTORE);
ERROR:  query has no destination for result data
HINT:  If you want to discard the results of a SELECT, use PERFORM instead.
CONTEXT:  PL/pgSQL function insertsubconfiguration(text,integer,hstore,hstore) line 11 at SQL statement
STATEMENT:  SELECT InsertSubConfiguration('tako',1,' "buffer_size"=>"1e6", "slot"=>"0xc000", '::HSTORE,' '::HSTORE);
ERROR:  syntax error at or near "PERFORM" at character 1
STATEMENT:  PERFORM InsertSubConfiguration('tako',1,' "buffer_size"=>"1e6", "slot"=>"0xc000", '::HSTORE,' '::HSTORE);
ERROR:  syntax error at or near "PERFORM" at character 1
STATEMENT:  PERFORM InsertSubConfiguration('tako',1,' "buffer_size"=>"1e6", "slot"=>"0xc000", '::HSTORE,' '::HSTORE);
ERROR:  syntax error at or near "PERFORM" at character 1
STATEMENT:  PERFORM InsertSubConfiguration('tako',1,' "buffer_size"=>"1e6", "slot"=>"0xc000", '::HSTORE,' '::HSTORE);
ERROR:  query has no destination for result data
HINT:  If you want to discard the results of a SELECT, use PERFORM instead.
CONTEXT:  PL/pgSQL function insertsubconfiguration(text,integer,hstore,hstore) line 11 at SQL statement
STATEMENT:  SELECT InsertSubConfiguration('tako',1,' "buffer_size"=>"1e6", "slot"=>"0xc000", '::HSTORE,' '::HSTORE);
ERROR:  syntax error at or near "','" at character 72
STATEMENT:  SELECT * FROM InsertMainConfiguration(' "boke"=>1, "tako"=>1, '::HSTORE','MyMain3');
ERROR:  invalid input syntax for integer: "MyMain3" at character 30
STATEMENT:  SELECT * FROM ListSubConfigs('MyMain3');
ERROR:  invalid input syntax for integer: "MyMain3" at character 30
STATEMENT:  SELECT * FROM ListSubConfigs('MyMain3');
ERROR:  invalid input syntax for integer: "MyMain3" at character 30
STATEMENT:  SELECT * FROM ListSubConfigs('MyMain3');
ERROR:  invalid input syntax for integer: "MyMain3" at character 30
STATEMENT:  SELECT * FROM ListSubConfigs('MyMain3');
ERROR:  function listsubconfig(unknown) does not exist at character 15
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
STATEMENT:  SELECT * FROM ListSubConfig('MyMain3');
ERROR:  invalid input syntax for integer: "MyMain3" at character 30
STATEMENT:  SELECT * FROM ListSubConfigs('MyMain3');
